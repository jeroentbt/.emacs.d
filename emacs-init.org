* Emacs Org Configuration
* Description
This file is tangled by init.el using =org-babel-load-file=. What this does is generate a =emacs-init.el= from the =emacs-lisp= source blocks.
* Prerequisites
** git
** cask
An emacs package manager: http://cask.github.io/installation.html
* Package Management

[[https://github.com/rdallasgray/pallet][Pallet]] is a very helpful package management tool for Emacs.
It utilizes a dependency management platform called [[https://github.com/cask/cask][Cask]],
to update a centralized =Cask= file when you install or remove packages.

** Cask
Cask is initialized in =init.el= with the following:
#+BEGIN_SRC emacs-lisp :tangle no
(require 'cask "~/.cask/cask.el")
(cask-initialize)
#+END_SRC

** Pallet
You can download all packages in your =Cask= file by using =M-x pallet-install=.
However, this should not be necessary.

** Install Packages
- Install [[https://github.com/cask/cask][Cask]].
- Run =cask install= in =$HOME/.emacs.d/=.

* The config
** Dependency Management with =req-package=

Where Pallet keeps track of the packages we have installed, =req-package=
handles all our internal package dependencies and configurations.

#+BEGIN_QUOTE
[[https://github.com/edvorg/req-package][req-package]] is a wrapper on top of [[https://github.com/jwiegley/use-package][use-package]], a package dependency
management tool. The documentation for =use-package= is immensely helpful for
figuring out how to describe package dependencies and settings. =req-package=
adds the =:require= keyword which allows you to define dependencies between
related packages.
#+END_QUOTE

Start using =req-package=
#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'req-package)
  (req-package pallet)
#+END_SRC

*** A word on using req-package

Loading of the required package is deferred if you use the
:commands, :bind, :mode or :interpreter (which all imply :commands)
or the :defer keyword

**** :require
load (and install when missing) dependencies
#+BEGIN_EXAMPLE emacs-lisp
  (req-package foo
      :require package)
#+END_EXAMPLE
#+BEGIN_EXAMPLE emacs-lisp
  (req-package foo
      :require (package package2))
#+END_EXAMPLE
**** :init
Will run immediately, even when loading is deferred.
Keep it as simple as possible and make sure it is able to run
#+BEGIN_EXAMPLE emacs-lisp
  (req-package foo
      :init
      (progn
          (setq foo-var t)
          (foo-mode 1))
#+END_EXAMPLE
**** :idle
Same as =init=, but will wait untill emacs is idle to execute.
See varriable use-package-idle-interval

Good for minor modes that take a long time to load
#+BEGIN_EXAMPLE emacs-lisp
  (req-package pabbrev
      :commands global-pabbrev-mode
      :idle (global-pabbrev-mode)
      :idle-priority 3) ;; lower is higher priority
#+END_EXAMPLE
**** :config
Will execute when package is actually loaded (when deferred)
**** :bind
Bind keys (defers)
cons or list of conses
#+BEGIN_EXAMPLE emacs-lisp
  (req-package foo
      :bind
      (("C-c" . some-defun)
          ("C-x" . some-other-defun))
#+END_EXAMPLE
**** :commands
create autoloads for these commands (defers untill these commands are used)
**** :mode
add to auto-mode-alist
#+BEGIN_EXAMPLE emacs-lisp
  (req-package foo
      :mode
      ("\\.py\\'" . python-mode))
#+END_EXAMPLE
#+BEGIN_EXAMPLE emacs-lisp
  (req-package foo
      :mode "\\.py\\'")
#+END_EXAMPLE
**** :interpreter
add to interpreter-mode-alist
#+BEGIN_EXAMPLE emacs-lisp
  (req-package foo
      :interpreter
      ("python" . python-mode))
#+END_EXAMPLE
**** :defer
explicitly defer loading
#+BEGIN_EXAMPLE emacs-lisp
  (req-package foo
      :defer t)
#+END_EXAMPLE
**** :if
predicate loading of module
#+BEGIN_EXAMPLE emacs-lisp
  (use-package edit-server
    :if window-system
    :init
    (progn
      (add-hook 'after-init-hook 'server-start t)
      (add-hook 'after-init-hook 'edit-server-start t)))
#+END_EXAMPLE
**** :disabled
t to disable loading entirely
**** :load-path
load path of the package/module's parent dir
Relative paths are prefixed with =user-emacs-directory=
#+BEGIN_EXAMPLE emacs-lisp :tangle no
  (req-package foo
      :load-path "some/path"
#+END_EXAMPLE
**** :diminish
prevent minor-mode from showing up (or change the string used) in the modeline
#+BEGIN_EXAMPLE emacs-lisp :tangle no
  (req-package foo
      :diminish foo "foo-minor-mode"
#+END_EXAMPLE

** System
First find out wether we're working on OSX or not

#+BEGIN_SRC emacs-lisp :tangle yes
  ;; Are we on a mac?
  (setq is-osx (equal system-type 'darwin))

  ;; On OS X GUI applications do not inherit variables from the shell
  ;; configuration and thus have a different $PATH
  ;; test by doing "M-: (executable-find "flake8")"
  ;; C-h v exec-path
  (when is-osx (progn (req-package exec-path-from-shell
                                   :init
                                   (exec-path-from-shell-initialize))

                      ;; This is for mu4e to be able to get gpg going (sig verifying etc)
                      ;; I was unable to M-x getenv RET GPG_AGENT_INFO (even if I manually set it,
                      ;; as gpg-agent form gpgtools.org does not export this)
                      ;; M-x shell-copy-environment-variable was no help either
                      ;; This should be no problem in *nix's
                      (setenv "GPG_AGENT_INFO" "~/.gnupg/S.gpg-agent")

                      ;; switch modifiers in system prefs
                      ;; (setq mac-option-modifier 'super)
                      ;; (setq mac-command-modifier 'meta)
                      (setq ns-function-modifier 'hyper)

                      ;; Ignore .DS_Store files with ido mode
                      (add-to-list 'ido-ignore-files "\\.DS_Store")))

#+END_SRC
*** File Paths
**** Dropbox
#+BEGIN_SRC emacs-lisp :tangle yes
    ;; define some external to emacs paths
    (setq dropbox "~/Dropbox")

#+END_SRC
**** TODO Load paths
Disabled for now
#+BEGIN_SRC emacs-lisp :tangle no
  (add-to-list 'load-path (expand-file-name "vendor"
                                            user-emacs-directory))
  (add-to-list 'custom-theme-load-path (expand-file-name "vendor/themes"
                                                         user-emacs-directory))
#+END_SRC
** Basics
   Some essential customizations.
*** The custom customizations

    Emacs let's you use the /customize/ interface to change things up.
    Using the following code we make sure everything gets put in and loaded from the correct file.

#+BEGIN_SRC emacs-lisp :tangle yes
    ;; Use a custom.el file for customizations and load it
    (setq custom-file (expand-file-name "custom.el"
                                        user-emacs-directory))
    (load custom-file)

#+END_SRC

*** The interface
**** Remove UI components
We defined earlier whether we are running on OSX. The variable =window-system= tells us in which window system we're running, if at all.

#+BEGIN_SRC emacs-lisp :tangle yes
    ;; Turn off mouse interface early in startup to avoid momentary display
    ;; menu can exist on osx when run as cocoa app
    (if (and is-osx (eq window-system "ns"))
        (if (fboundp 'menu-bar-mode) (menu-bar-mode t))
        (if (fboundp 'menu-bar-mode) (menu-bar-mode -1)))
    (if (fboundp 'tool-bar-mode) (tool-bar-mode -1))
    (if (fboundp 'scroll-bar-mode) (scroll-bar-mode -1))
#+END_SRC

**** Interface defaults
Some sensible defaults

#+BEGIN_SRC emacs-lisp :tangle yes
  ;; No splash screen
  ;; Will default to the *scratch* buffer
  (setq inhibit-startup-message t)

  ;; Full path in frame title
  (when window-system
    (setq frame-title-format '(buffer-file-name "%f" ("%b"))))

  ;; don't beep but flash the screen
  ;; font-lock-mode provides the colors for spec languages, set max fontification (1-3)
  ;; force color theme (no increments)
  ;; don't truncate on partial width
  (setq visible-bell t
        font-lock-maximum-decoration t
        color-theme-is-global t
        truncate-partial-width-windows nil)

  ;; Enable syntax highlighting for older Emacsen that have it off
  (global-font-lock-mode t)

  ;; Highlight current line
  (global-hl-line-mode 1)

  ;; Don't defer screen updates when performing operations
  (setq redisplay-dont-pause t)

  ;; Highlight matching parentheses when the point is on them.
  (show-paren-mode 1)

  (blink-cursor-mode -1)

  ;; Show active region
  (transient-mark-mode 1)
  (make-variable-buffer-local 'transient-mark-mode)
  (put 'transient-mark-mode 'permanent-local t)
  (setq-default transient-mark-mode t)


  ;; Show me empty lines after buffer end
  (set-default 'indicate-empty-lines t)

  ;; smaller cursor
  (setq cursor-type 'bar)

  ;; Use the x clipboard (should have been enabled by default)
  (setq x-select-enable-clipboard t)

  ;; after mouse selection in X11, you can paste by `yank' in emacs
  (setq x-select-enable-primary t)

  ;; faster keystroke echo (shows you what command you're typing)
  (setq echo-keystrokes 0.1)
#+END_SRC

**** Appearance
#+BEGIN_SRC emacs-lisp :tangle yes
  ;; easily switch between all themes
  ;; (req-package themepark-mode)
  ;; not available in package.el repos, too lazy to add it manually

  ;; the current theme of choice
  (load-theme 'solarized-dark)

  ;; set the font
  (if is-osx
      (set-face-attribute 'default nil :family "source code pro" :weight "light"))
;      (set-default-font "xft:Source Code Pro:size=10"))

  ;; set a default fontset to use for displaying unicode characters
  (set-fontset-font "fontset-default" nil
                    (font-spec :size 16 :name "Symbola"))

#+END_SRC

**** Mode Line

     I'm using [[https://github.com/Malabarba/smart-mode-line/][smart-mode-line]] to build me a nice mode-line.
     To clean up some minor modes indicators, [[http://www.emacswiki.org/emacs/DiminishedModes][diminish.el]] is used. This could potentially be replaced by [[https://github.com/Malabarba/rich-minority][rich-minority]].

#+BEGIN_SRC emacs-lisp :tangle yes
  ;;(size-indication-mode t)

  (req-package smart-mode-line
               :require diminish
               :config
               (progn
                   (setq sml/theme 'automatic)
                   ;; replace common paths
                   (add-to-list 'sml/replacer-regexp-list '("^~/Projects/" ":P:"))
                   (add-to-list 'sml/replacer-regexp-list '("^:P:Syntra" ":SVL:") t)

                   (setq sml/projectile-replacement-format "[%s]")
                   (setq sml/use-projectile-p 'after-prefixes)

                   ;; Major mode stays left, everything after gets alligned right
                   (setq sml/mode-width 'right)
                   ;; Set min and max buffer name length
                   (setq sml/name-width '(12 . 54))
                   (setq sml/shorten-modes t)

                   ;; hide minor modes
                   (eval-after-load "Projectile" '(diminish 'projectile-mode))
                   (eval-after-load "Guide-Key" '(diminish 'guide-key-mode))
                   (eval-after-load "Magit-Auto-Revert" '(diminish 'magit-auto-revert-mode))
                   (eval-after-load "subword" '(diminish 'subword-mode))
                   (eval-after-load "smartparens" '(diminish 'smartparens-mode "("))
                   (eval-after-load "indent-guide" '(diminish 'indent-guide-mode " |"))
                   )
               :init
               (sml/setup))
#+END_SRC
**** Buffers and windows
***** ace-window
Ace-window offers an ace-jump like interface for jumping to, switching and deleting windows.
1 universal argument moves current and called window
2 universal arguments deletes called window

As abo-abo suggests, I'm using the home row to select the windows

n key (as well as another call of M-o) will switch to the previous window
#+BEGIN_SRC emacs-lisp :tangle yes
    (req-package ace-window
      :init
      (setq aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l)
            aw-background nil
            aw-flip-keys '("n" "M-o"))
      (custom-set-faces
       '(aw-leading-char-face ((t (:inherit ace-jump-face-foreground :height 3.0)))))
      :bind
      (("M-o" . ace-window)))
#+end_src

***** ibuffer
Start using ibuffer
#+BEGIN_SRC emacs-lisp :tangle yes
  ;; use ibuffer
  (bind-key "C-x C-b" 'ibuffer)
#+END_SRC
Here we sort the buffers for a nicer ibuffer view
#+BEGIN_SRC emacs-lisp :tangle yes
  ;; sort buffers
  (setq ibuffer-saved-filter-groups
        `(("default"
           ("emacs.d"
            (filename . "/.emacs.d/"))
           ("emacs"
            (or
             (name . "^\\*scratch\\*$")
             (name . "^\\*Messages\\*$")
             (name . "^\\*Help\\*$")
             (name . "^\\*Completions\\*$")
             (name . "^\\*Quail Completions\\*$")
             (name . "^\\*Packages\\*$")
             (name . "^\\*Backtrace\\*$")
             (name . "^\\*Compile-Log\\*$")))
           ("Code"
            (or
             (mode . c-mode)
             (mode . c++-mode)
             (mode . perl-mode)
             (mode . python-mode)
             (mode . ruby-mode)
             (mode . emacs-lisp-mode)
             (mode . lisp-mode)
             (mode . sh-mode)
             (mode . php-mode)
             (mode . xml-mode)
             (mode . html-mode)
             (mode . web-mode)
             (mode . css-mode)
             (mode . js-mode)
             (mode . js2-mode)
             (mode . js3-mode)))
           ("Mail"
            (or
             (mode . message-mode)
             (mode . mail-mode)
             (mode . mu4e-main-mode)
             (mode . mu4e-headers-mode)
             (mode . mu4e-view-mode)
             (mode . mu4e-compose-mode)))
           ("Chat"
            (or
             (mode . erc-mode)
             (name . "^\\#ERC Mentions$")
             (mode . identica-mode)
             (mode . twitter-mode)))
           ("Dired"
            (or
             (mode . dired-mode)
             (mode . direx-mode)))
           ("Org"
            (mode . org-mode))
           )))

  (setq ibuffer-show-empty-filter-groups nil)

  (add-hook 'ibuffer-mode-hook
            (lambda ()
              (ibuffer-switch-to-saved-filter-groups "default")))
#+END_SRC
****** TODO look in to ibuffer-vc.el
https://github.com/purcell/ibuffer-vc/blob/master/ibuffer-vc.el
***** resizing
#+BEGIN_SRC emacs-lisp :tangle yes
  ;; window resizing
  (bind-key "S-C-<left>" 'shrink-window-horizontally)
  (bind-key "S-C-<right>" 'enlarge-window-horizontally)
  (bind-key "S-C-<down>" 'shrink-window)
  (bind-key "S-C-<up>" 'enlarge-window)
#+END_SRC
**** Darkroom
Darkroom mode offers a write centric, no clutter interface

#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package darkroom)
#+end_src

**** Line numbers
#+BEGIN_SRC emacs-lisp :tangle yes
  (global-unset-key "\C-x\l")
  ;; Toggle linum-mode, remap count lines
  (bind-key "C-x l n" 'linum-mode)
  (bind-key "C-x l c" 'count-lines-page)

#+END_SRC
**** Indent guides
#+BEGIN_SRC emacs-lisp :tangle yes
    (req-package indent-guide
        :init (indent-guide-global-mode))
#+END_SRC
***** TODO bind a key to toggle indent-guide
*** General interaction and settings

**** Defaults
#+BEGIN_SRC emacs-lisp :tangle yes
  ;; Auto refresh buffers when edits occur outside emacs
  (global-auto-revert-mode 1)

  ;; Save point position between sessions
  (req-package saveplace
               :init
               (setq-default save-place t)
               :config
               (setq save-place-file (expand-file-name ".places" user-emacs-directory)))

  ;; this is disabled by default
  (put 'narrow-to-region 'disabled nil)

  ;; Save a list of recent files visited. (open recent file with C-x f)
  (recentf-mode 1)
  (setq recentf-max-saved-items 100) ;; just 20 is too recent

  ;; Undo/redo window configuration with C-c <left>/<right>
  (winner-mode 1)

  ;; Never insert tabs
  ;; Tabs can be inserted with C-q C-i (quoted insert indent)
  (set-default 'indent-tabs-mode nil)

  ;; Easily navigate sillycased words
  (global-subword-mode 1)

  ;; Don't break lines for me, please
  ;; This is nicer with 'visual-line-mode (and adaptive wrap)
  (setq-default truncate-lines t)

  ;; Keep cursor away from edges when scrolling up/down
  (req-package smooth-scrolling)

  ;; Allow recursive minibuffers
  ;; (setq enable-recursive-minibuffers t)

  ;; Don't be so stingy on the memory, we have lots now. It's the distant future.
  (setq gc-cons-threshold 20000000)

  ;; Represent undo-history as an actual tree (visualize with C-x u)
  (req-package undo-tree
               :init
               (global-undo-tree-mode)
               :config
               (setq undo-tree-mode-lighter ""))

  ;; Sentences do not need double spaces to end. Period.
  (set-default 'sentence-end-double-space nil)

  ;; Add parts of each file's directory to the buffer name if not unique
  ;; not available on MELPA
  (req-package uniquify
               :init
               (setq uniquify-buffer-name-style 'forward))

  ;; A saner ediff
  (setq ediff-diff-options "-w")
  (setq ediff-split-window-function 'split-window-horizontally)
  (setq ediff-window-setup-function 'ediff-setup-windows-plain)

  ;; Nic says eval-expression-print-level needs to be set to nil (turned off) so
  ;; that you can always see what's happening.
  (setq eval-expression-print-level nil)

  ;; When popping the mark, continue popping until the cursor actually moves
  ;; Also, if the last command was a copy - skip past all the expand-region cruft.
  (defadvice pop-to-mark-command (around ensure-new-position activate)
    (let ((p (point)))
      (when (eq last-command 'save-region-or-current-line)
        ad-do-it
        ad-do-it
        ad-do-it)
      (dotimes (i 10)
        (when (= p (point)) ad-do-it))))

  ;; Smart M-x : ido like interactivity for M-x
  ;; when ido-ubiquitous is used, smex is just used to keep
  ;; a history of last used commands.
  ;; TODO: check previous statement about smex and ido-ubiquitous
  (req-package smex
               :require ido
               :init
               (smex-initialize)
               :bind
               (;; ("M-x" . smex) ;; -> replace by helm
                ("M-X" . smex-major-mode-commands)
                ("C-c C-c M-x" . execute-extended-command)))

  ;; Hide mousepointer when typing
  (setq make-pointer-invisible t)

  ;; erc made the pointer go off screen, forcing a recenter
  ;; oufo on #emacs suggested this: (works great)
  (setq scroll-conservatively 1000)

  ;; simple y or n questions
  (defalias 'yes-or-no-p 'y-or-n-p)

  ;; do not use shift select
  (setq shift-select-mode nil)

  ;; replace region when typing
  (delete-selection-mode t)

  ;; hungry delete mode
  ;; Plain and simple, it makes backspace and C-d erase all consecutive white space
  ;; (instead of just one). Use it everywhere.
  (req-package hungry-delete
               :init
               (global-hungry-delete-mode))
#+END_SRC
***** Search with regex
#+BEGIN_SRC emacs-lisp :tangle yes
  ;; Search always regex
  (bind-key "C-s" 'isearch-forward-regexp)
  (bind-key "C-r" 'isearch-backward-regexp)
  (bind-key "C-M-s" 'isearch-forward)
  (bind-key "C-M-r" 'isearch-backward)
#+END_SRC
***** Backups
from: http://ergoemacs.org/emacs/emacs_set_backup_into_a_directory.html
This function will mirror all directories at the given backup dir.
For example, if you are editing a file /Users/j/web/xyz/myfile.txt,
and your backup root is
/Users/j/.emacs.d/emacs-backup/, then the backup will be at
/Users/j/.emacs.d/emacs-backup/Users/j/web/xyz/myfile.txt~.

#+BEGIN_SRC emacs-lisp :tangle yes
  ;; make backup to a designated dir, mirroring the full path
  (defun my/backup-file-full-dir (fpath)
    "Return a new backup file path of a given file path.
  If the new path's directories does not exist, create them."
    (let* (
          (backupRootDir (expand-file-name
                   (concat user-emacs-directory "backups")))
          ;;(backupRootDir "~/.emacs.d/emacs-backup/")
          (filePath (replace-regexp-in-string "[A-Za-z]:" "" fpath )) ; remove Windows driver letter in path, ⁖ “C:”
          (backupFilePath (replace-regexp-in-string "//" "/" (concat backupRootDir filePath "~") ))
          )
      (make-directory (file-name-directory backupFilePath) (file-name-directory backupFilePath))
      backupFilePath
    )
  )

  ;; Actually set the backup dir now
  (setq make-backup-file-name-function 'my/backup-file-full-dir)
#+END_SRC
***** Dates and calendar

#+BEGIN_SRC emacs-lisp :tangle yes
  (setq calendar-week-start-day 1
        european-calendar-style t)
#+end_src
**** Scratch buffer

***** scratch buffer mode

      #+BEGIN_SRC emacs-lisp :tangle yes
        (setq initial-major-mode 'org-mode)
      #+end_src

***** no initial message

      #+BEGIN_SRC emacs-lisp :tangle yes
        (setq initial-scratch-message "")
      #+end_src

**** Better visual line mode
***** Adaptive wrap
Visual line mode does not take indentation in to account. adaptive-wrap-prefix-mode solves that.
from: http://stackoverflow.com/a/13561223/1929897
#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package adaptive-wrap
               :bind
               ("C-x l w" . visual-line-mode))

  (when (fboundp 'adaptive-wrap-prefix-mode)
    (defun my/activate-adaptive-wrap-prefix-mode ()
      "Toggle `visual-line-mode' and `adaptive-wrap-prefix-mode' simultaneously."
      (adaptive-wrap-prefix-mode (if visual-line-mode 1 -1)))
    (add-hook 'visual-line-mode-hook 'my/activate-adaptive-wrap-prefix-mode))
#+END_SRC
***** window margin
      :PROPERTIES:
      :home:      [[https://github.com/aculich/window-margin.el][github]]
      :END:
This package will, while activating visual line mode, also use the margins to set the width of the display.

#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package window-margin
    :bind ("C-x l W" . window-margin-mode))
#+end_src


**** Ace jump mode
Ace jump mode! C-c C-c to switch from word to char mode once in ace jump mode.
Otherwise use universal C-u to toggle behaviour
#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package ace-jump-mode
               :bind
               ("C-c SPC" . ace-jump-mode))
#+END_SRC
**** Smarter move to beginning of line
A nice function that knows where the business part of a line starts
from: http://emacsredux.com/blog/2013/05/22/smarter-navigation-to-the-beginning-of-a-line/

#+BEGIN_SRC emacs-lisp :tangle yes
  (defun my/smarter-move-beginning-of-line (arg)
    "Move point back to indentation of beginning of line.

  Move point to the first non-whitespace character on this line.
  If point is already there, move to the beginning of the line.
  Effectively toggle between the first non-whitespace character and
  the beginning of the line.

  If ARG is not nil or 1, move forward ARG - 1 lines first.  If
  point reaches the beginning or end of the buffer, stop there."
    (interactive "^p")
    (setq arg (or arg 1))

    ;; Move lines first
    (when (/= arg 1)
      (let ((line-move-visual nil))
        (forward-line (1- arg))))

    (let ((orig-point (point)))
      (back-to-indentation)
      (when (= orig-point (point))
        (move-beginning-of-line 1))))

  (bind-key "C-a" 'my/smarter-move-beginning-of-line)
#+END_SRC
***** TODO also add move to beginning of heading in org                :idea:
C-a in org-mode is org-move-to-beginning-of-line
IT would be nice to also move to the beginning of the heading, after the *s
**** Kill whole line
Easier than C-a, C-k
#+BEGIN_SRC emacs-lisp :tangle yes
  ;; kill whole line with C-; (because ; is close to k)
  (bind-key "C-;" 'kill-whole-line)
#+END_SRC
***** TODO C-; is bound by flyspell to auto correct previous word       :bug:
**** Browse kill ring
A helm alternative exists (helm-show-kill-ring), but browse kill ring
offer a lot more features (delete, edit, ...).
Keeping this one in, with some finger gymnsastics.
#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package browse-kill-ring
               :bind
               ("C-M-y" . browse-kill-ring))
#+END_SRC
**** Copy/Cut curent line if no selection
     :PROPERTIES:
     :source:   http://ergoemacs.org/emacs/emacs_copy_cut_current_line.html
     :updated:  2014-09-16
     :END:

Normally, when you would want to copy a line you would do something like
C-a, C-k, C-/
or, if you use kill-whole line
C-;, C-/
Lets save a keystroke!

Define the functions
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun xah-copy-line-or-region ()
      "Copy current line, or text selection.
  When `universal-argument' is called first, copy whole buffer (but respect `narrow-to-region')."
      (interactive)
      (let (p1 p2)
          (if (null current-prefix-arg)
              (progn (if (use-region-p)
                         (progn (setq p1 (region-beginning))
                             (setq p2 (region-end)))
                         (progn (setq p1 (line-beginning-position))
                             (setq p2 (line-end-position)))))
              (progn (setq p1 (point-min))
                  (setq p2 (point-max))))
          (kill-ring-save p1 p2)))

  (defun xah-cut-line-or-region ()
      "Cut current line, or text selection.
  When `universal-argument' is called first, cut whole buffer (but respect `narrow-to-region')."
      (interactive)
      (let (p1 p2)
          (if (null current-prefix-arg)
              (progn (if (use-region-p)
                         (progn (setq p1 (region-beginning))
                             (setq p2 (region-end)))
                         (progn (setq p1 (line-beginning-position))
                             (setq p2 (line-beginning-position 2)))))
              (progn (setq p1 (point-min))
                  (setq p2 (point-max))))
          (kill-region p1 p2)))
#+END_SRC
Set the keybindings (replacing the default behaviour)
#+BEGIN_SRC emacs-lisp :tangle yes
  (bind-key "M-w" 'xah-copy-line-or-region)
  (bind-key "C-w" 'xah-cut-line-or-region)
#+END_SRC
**** (Un)comment region or line
from: http://stackoverflow.com/a/9697222/1929897
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun my/comment-or-uncomment-region-or-line ()
      "Comments or uncomments the region or the current line if there's no active region."
      (interactive)
      (let (beg end)
          (if (region-active-p)
              (setq beg (region-beginning) end (region-end))
              (setq beg (line-beginning-position) end (line-end-position)))
          (comment-or-uncomment-region beg end)
          (next-line)))
   (bind-key "C-c /" 'my/comment-or-uncomment-region-or-line)
#+END_SRC
**** popwin
Pop!
#+BEGIN_SRC emacs-lisp :tangle yes
    (req-package popwin
                 :init
                 (require 'popwin)
                 (popwin-mode t))
#+END_SRC
**** Some help
***** guide-key                                                  :mode:minor:
An interface to use a tooltip window to display guide-key info is also available:
[[https://github.com/aki2o/guide-key-tip][guide-key-tip.el]]. I'm sticking with the regular one for now. And hope discover gets some more love.
#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package guide-key
               :init
               (guide-key-mode 1)
               :config
               (setq guide-key/guide-key-sequence '("C-c p" ;; projectile
                                                    "C-c !" ;; flycheck
                                                    "C-x r" ;; ... stuff
                                                    "C-x 4" ;; file other window
                                                    "C-x v" ;; generic version controll
                                                    "C-x 8" ;; special chars
                                                    "C-x x" ;; persp
                                                    "H-x" ;; start apps
                                                    (js2-mode "C-c C-m") ;; js2-refactor
                                                    )
                     guide-key/recursive-key-sequence-flag t
                     guide-key/popup-window-position 'bottom))

#+END_SRC
***** flycheck code verification
****** Usage
http://flycheck.readthedocs.org
Flycheck will run external commands to verify code. To find out what checkers can be used do
#+BEGIN_EXAMPLE
M-x flycheck-describe-checker
#+END_EXAMPLE
It's default keybinding prefix is 'C-c !'
c for flycheck buffer
n-p for navigating errors
But guide-key should have your back
****** Modeline
#+BEGIN_SRC emacs-lisp :tangle yes
  (defface my/flycheck-grey
      '((((class color) (min-colors 88))
            :foreground "grey"))
      "Face for my/flycheck-mode-line-status-icon"
      :group 'my/flycheck-icon
      )
  (defface my/flycheck-red
      '((((class color) (min-colors 88))
            :foreground "red"))
      "Face for my/flycheck-mode-line-status-icon"
      :group 'my/flycheck-icon
      )
  (defface my/flycheck-orange
      '((((class color) (min-colors 88))
            :foreground "orange"))
      "Face for my/flycheck-mode-line-status-icon"
      :group 'my/flycheck-icon
      )
  (defface my/flycheck-green
      '((((class color) (min-colors 88))
            :foreground "green"))
      "Face for my/flycheck-mode-line-status-icon"
      :group 'my/flycheck-icon
      )

  (defun my/flycheck-mode-line-status-text (&optional status)
    "Get a coloured icon (and some numbers) describing STATUS for use in the mode line.

  STATUS defaults to `flycheck-last-status-change' if omitted or
  nil."
    (let ((icon (pcase (or status flycheck-last-status-change)
                  (`not-checked (propertize (string 32 #xF10C) 'font-lock-face 'my/flycheck-grey))
                    ;;  
                  (`no-checker (propertize (string 32 #xF05C) 'font-lock-face 'my/flycheck-grey))
                    ;;  
                  (`running (propertize (string 32 #xF05D) 'font-lock-face 'my/flycheck-grey))
                    ;;  
                  (`errored (propertize (string 32 #xF05C) 'font-lock-face 'my/flycheck-red))
                    ;;  
                  (`finished
                      (if flycheck-current-errors
                          (let ((error-counts (flycheck-count-errors
                                               flycheck-current-errors)))
                              (concat
                                  (if (> (cdr (assq 'error error-counts)) 0)
                                      (propertize (string 32 #xF057) 'font-lock-face 'my/flycheck-red)
                                        ;;  
                                      (propertize (string 32 #xF057) 'font-lock-face 'my/flycheck-orange))
                                      ;;  
                                  (format "%s/%s"
                                      (or (cdr (assq 'error error-counts)) 0)
                                      (or (cdr (assq 'warning error-counts)) 0))))
                          (propertize (string 32 #xF058) 'font-lock-face 'my/flycheck-green)
                          ;;  
                          ))
                  (`interrupted (propertize (string 32 #xF056) 'font-lock-face 'my/flycheck-grey))
                    ;;  
                  (`suspicious (propertize (string 32 #xF059) 'font-lock-face 'my/flycheck-grey))
                    ;;  
                    )))
      (concat " " icon)))

#+END_SRC
******* TODO flycheck mode line
activate outside of customize
Make colors appear on modeline
****** Setup
#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package flycheck)
#+END_SRC
***** discover
#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package discover
               :init
               (global-discover-mode 1))
#+END_SRC
***** dash
****** dash (OSX)
Dash is an offline documentation browser for OSX
http://kapeli.com/dash
Zeal is the equivalent on linux.
#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package dash-at-point
      :if is-osx
      :bind ("C-c d" . dash-at-point))
#+END_SRC
****** helm-dash
#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package helm-dash
    :require (helm esqlite)
    :config

    (defun my/dash-install-docset (docset)
      (let ((this-docset-path (expand-file-name
                               (concat docset ".docset")
                               helm-dash-docsets-path)))
        (unless (file-exists-p this-docset-path)
          (helm-dash-install-docset docset))))

    ;; install docsets
    (my/dash-install-docset "JavaScript")
    (my/dash-install-docset "jQuery")
    (my/dash-install-docset "Grunt")
    (my/dash-install-docset "D3JS")
    (my/dash-install-docset "Meteor")
    (my/dash-install-docset "MomentJS")
    (my/dash-install-docset "Lo-Dash")
    (my/dash-install-docset "UnderscoreJS")

    (my/dash-install-docset "HTML")
    (my/dash-install-docset "Bootstrap_3")
    (my/dash-install-docset "Foundation")
    (my/dash-install-docset "Emmet")

    (my/dash-install-docset "CSS")
    (my/dash-install-docset "Less")
    (my/dash-install-docset "Sass")
    (my/dash-install-docset "Stylus")
    (my/dash-install-docset "Compass")
    (my/dash-install-docset "Bourbon")

    (my/dash-install-docset "Bash")
    (my/dash-install-docset "Font_Awesome")

    (my/dash-install-docset "MongoDB")

    (my/dash-install-docset "Markdown")
    (my/dash-install-docset "SVG")

    (my/dash-install-docset "Processing")

    ;;(setq helm-dash-browser-func 'eww)
    (setq helm-dash-browser-func 'browse-url)

    :bind
    (("C-c d d" . helm-dash-at-point)
     ("C-c d SPC" . helm-dash)
     ("C-c d a" . helm-dash-activate-docset)
     ("C-c d r" . helm-dash-reset-connections)))

#+END_SRC
**** expand-region                                               :mode:minor:
#+BEGIN_SRC emacs-lisp :tangle yes
    (req-package expand-region
                 :bind
                 ("C-=" . er/expand-region))
#+END_SRC

**** highlight-symbol
I basically just use this to highlight, none of the query replace and moving around stuff
#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package highlight-symbol)
#+END_SRC
**** multiple-cursors                                            :mode:minor:
#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package multiple-cursors
               :bind
               (("C->" . mc/mark-next-like-this)
                ("C-<" . mc/mark-previous-like-this)
                ("C-c C-<" . mc/mark-all-like-this)
                ("C-c C->" . mc/edit-lines))) ;; adds a cursor to all lines in current region

#+END_SRC

**** smartparens                                                 :mode:minor:
#+BEGIN_SRC emacs-lisp :tangle yes
    (req-package smartparens-config
                 :require
                 (smartparens)
                 :init
                 (smartparens-global-mode))

#+END_SRC

**** dired
This little variable defines dired to guess the directory to move/copy to by looking at a potential dired in another window.
Making it behave somewhat like a two-pane file manager
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq dired-dwim-target t)
#+END_SRC
***** dired-x
Dired extra. Extra features for dired
#+BEGIN_SRC emacs-lisp :tangle yes
  (add-hook 'dired-load-hook
      (function (lambda () (load "dired-x"))))
#+END_SRC
***** direx
Direx shows the dir or projects file structure.
We'll be using popwin to make it pop!
#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package direx
               :require
               (direx-project popwin)
               :config
               (progn (push '(direx:direx-mode :position left :width 40 :dedicated t)
                            popwin:special-display-config)
                      (global-set-key (kbd "C-x C-j") 'direx-project:jump-to-project-root-other-window)))
#+END_SRC
**** recent files
This functionality is offered by helm mini. See helm config

Find recent files
from: Magnars https://github.com/magnars/.emacs.d/blob/c1a481c9ba85ab3127bb77c7b60689abbbeb5611/defuns/buffer-defuns.el
#+BEGIN_SRC emacs-lisp :tangle no
  (req-package s)

  (defvar user-home-directory (concat (expand-file-name "~") "/"))

  (defun shorter-file-name (file-name)
    (s-chop-prefix user-home-directory file-name))

  (defun recentf--file-cons (file-name)
    (cons (shorter-file-name file-name) file-name))

  (defun recentf-ido-find-file ()
    "Find a recent file using ido."
    (interactive)
    (let* ((recent-files (mapcar 'recentf--file-cons recentf-list))
           (files (mapcar 'car recent-files))
           (file (completing-read "Choose recent file: " files)))
      (find-file (cdr (assoc file recent-files)))))

  (bind-key "C-x f" 'recentf-ido-find-file)
#+END_SRC
**** move and rename files & buffers
Small conveniece defuns by steveyegge2
https://sites.google.com/site/steveyegge2/my-dot-emacs-file
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun rename-file-and-buffer (new-name)
    "Renames both current buffer and file it's visiting to NEW-NAME." (interactive "sNew name: ")
    (let ((name (buffer-name))
          (filename (buffer-file-name)))
      (if (not filename)
          (message "Buffer '%s' is not visiting a file!" name)
        (if (get-buffer new-name)
            (message "A buffer named '%s' already exists!" new-name)
          (progn (rename-file name new-name 1)
                 (rename-buffer new-name)
                 (set-visited-file-name new-name)
                 (set-buffer-modified-p nil))))))

  (defun move-file-and-buffer-to-dir (dir)
   "Moves both current buffer and file it's visiting to DIR." (interactive "DNew directory: ")
   (let* ((name (buffer-name))
          (filename (buffer-file-name))
           (dir
           (if (string-match dir "\\(?:/\\|\\\\)$")
           (substring dir 0 -1) dir))
           (newname (concat dir "/" name)))

     (if (not filename)
         (message "Buffer '%s' is not visiting a file!" name)
       (progn (copy-file filename newname 1)
              (delete-file filename)
              (set-visited-file-name newname)
              (set-buffer-modified-p nil)
              t))))

#+END_SRC
**** Auto complete
#+BEGIN_SRC emacs-lisp :tangle no
  (req-package auto-complete
               :init
               ;; (add-to-list 'ac-dictionary-directories "~/.emacs.d/ac-dict")
               (require 'auto-complete-config)
               (ac-config-default))

#+END_SRC

***** company-mode
Looks like a nice alternative with less confusing completion
http://www.reddit.com/r/emacs/comments/2ekw22/autocompletemode_vs_companymode_which_is_better/

#+BEGIN_SRC emacs-lisp :tangle yes
    (req-package company
      :init (global-company-mode)
      :config (setq company-idle-delay 0.3
                    company-minimum-prefix-length 2
                    company-transformers '(company-sort-by-occurrence)
                    company-auto-complete '('company-explicit-action-p)
                    company-auto-complete-chars '(32 40 41 46)
                    company-selection-wrap-around t
                    company-show-numbers t
                    company-tooltip-align-annotations t
                    company-tooltip-limit 20
                    company-tooltip-margin 2
                    company-tooltip-minimum-width 20)
       :bind ("M-<tab>" . company-complete))
#+END_SRC

**** yasnippet

#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package yasnippet
    :init (yas-global-mode 1)
    :config (add-to-list 'company-backends 'company-yasnippet))
#+END_SRC

**** Tramp
Tramp is fastest over ssh (for not to large files)
Or open files as root
#+BEGIN_EXAMPLE
C-x C-f /sudo::/etc/someconf
C-x C-f /some.server.com:/etc/someconf
#+END_EXAMPLE
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq tramp-default-method "ssh")
#+END_SRC
***** sudo a file on a remote host
This little line of magic lets you connect to a remote host and sudo in to a file.
The variable tramp-default-proxies-alist is available only after tramp has loaded, hence eval-after-load
#+BEGIN_EXAMPLE
C-x C-f /sudo:some.server.com:/etc/someconf
#+END_EXAMPLE
In order to specify multiple hops, it is possible to define a proxy host to pass through, via the variable tramp-default-proxies-alist. This variable keeps a list of triples (host user proxy).
Entries are added to the top of a list. The most relevant entry should therefor be entered last
#+BEGIN_SRC emacs-lisp :tangle yes
  (eval-after-load "tramp"
      '(add-to-list 'tramp-default-proxies-alist
           '(".*" "\\`root\\'" "/ssh:%h:")))
#+END_SRC
But make sure we don't need to go through ssh on our own machine
#+BEGIN_SRC emacs-lisp :tangle yes
  (eval-after-load "tramp"
      '(add-to-list 'tramp-default-proxies-alist
           '((regexp-quote (system-name)) nil nil)))
#+END_SRC
***** More on proxies
****** Ad-hoc
An ad-hoc method of using Tramp with multiple hops is possible with the folowing syntax
#+BEGIN_EXAMPLE
C-x C-f /ssh:secureuser@protectionhost|ssh:you@thehosttoworkon:/path
#+END_EXAMPLE
****** using .ssh/config
This allows you to hop even for ssh, scp etc.
#+BEGIN_SRC config :tangle no
Host hopping
User yourusername
HostName hoppinghostname

Host some hostname patterns
User yourusername
ProxyCommand ssh -q hopping exec nc %h %p
#+END_SRC
**** Quitting emacs
A little reworking of the default to close windows, but keep the deamon running.
And a way to effectively kill emacs
#+BEGIN_SRC emacs-lisp :tangle yes
  ;; define function to shutdown emacs server instance
  (defun my/server-stop ()
    "Save buffers, Quit, and Shutdown (kill) server"
    (interactive)
    (save-some-buffers)
    (kill-emacs)
    )

  ;; I don't need to kill emacs that easily
  ;; the mnemonic is C-x REALLY QUIT
  (bind-key "C-x r q" 'my/server-stop)
  (bind-key "C-x C-c" 'delete-frame)
#+END_SRC
**** Rainbow mode
Colorizes color values in your buffer
#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package rainbow-mode)
#+END_SRC
**** paradox (extended package-menu)
To use it, simply call M-x paradox-list-packages (instead of the regular list-packages).
This will give you most features out of the box. If you want to be able to star packages as well, just configure the paradox-github-token variable then call paradox-list-packages again.

If you'd like to stop using Paradox, you may call paradox-disable and go back to using the regular list-packages.
#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package paradox)
#+END_SRC
press h for help
**** Webjump

Webjump lets you quickly search google, wikipedia, emacs wiki, ...
It is a built-in package and allready has a couple of sites coded in.
But it's fairly easy to define your own:

#+BEGIN_SRC emacs-lisp :tangle yes
        (defvar webjump-my-sites
          `(
               ("Arch forums" .
                   [simple-query
                       "https://bbs.archlinux.org/"
                       "https://bbs.archlinux.org/search.php?action=search&keywords="
                       ,(concat ;; fluxBB options
                            ;; "&author=username"
                            "&forum_id=-1" ;; all forums
                            "&search_in=topic" ;; [all/message/topic]
                            "&sort_by=0" ;; 0 (post_time) / 1 (author) / 2 (subject) / 3 (forum)
                            "&sort_dir=DESC" ;; DESC/ASC
                            "&show_as=topics" ;; topics/posts
                            )])
               ("ArchWiki" .
                   [simple-query
                       "https://wiki.archlinux.org/"
                       "https://wiki.archlinux.org/index.php?title=Special%3ASearch&fulltext=Search&search="
                       ""]))
          "My webjump sites")

        (req-package webjump
            :config
            (setq webjump-sites
                (append
                    webjump-my-sites
                    webjump-sample-sites))
            :bind   (("C-x g" . webjump)
                     ("C-x M-g" . browse-url-at-point)))
#+END_SRC
**** TODO history - source code navigation
A more intuitive way of popping the mark (which I never really started
using)
[[https://github.com/boyw165/history][github]]
** Secrets
Some configuration options (like server names, ports, passwords) are best kept secret.
I keep them in a gpg encrypted file =private.el.gpg=.
Because emacs will ask you for the password of your gpg key, loading the file on
startup will block starting =emacs --deamon=.
I therefor load this file only when needed.

#+BEGIN_SRC emacs-lisp :tangle yes
  (defvar my/secrets-loaded nil
"Is t when my secrets file (private.el.gpg) has been loaded.

Just to prevent it from trying to load it twice.")

    (defun my/load-secrets (where)
    "Load secrets from private.el.gpg if not allready done so"
        (unless my/secrets-loaded
            (load (expand-file-name "private.el.gpg"
                      user-emacs-directory))
            (message "private.el loaded by %s" where)))
#+END_SRC
** Git
*** magit                                                        :mode:major:
The git interface in emacs
#+BEGIN_SRC emacs-lisp :tangle yes
        (req-package magit
                     :bind
                     ("C-x m" . magit-status)
                     :init
                     (setq magit-last-seen-setup-instructions "1.4.0"))
#+END_SRC
*** git-timemachine                                              :mode:major:
Allows you to walk though different versions of a file
#+BEGIN_SRC emacs-lisp :tangle yes
    (req-package git-timemachine
                 :bind
                 ("C-x M" . git-timemachine))
#+END_SRC
*** git-messenger
Allows you to see who's to blame for the current line
M-w	Copy commit message and quit
c	Copy commit ID and quit
d	Pop up git diff of last change of this line
s	Pop up git show --stat of last change of this line
S	Pop up git show --stat -p of last change of this line
q	Quit
#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package git-messenger
      :bind
      ("C-x v p" . git-messenger:popup-message))
#+END_SRC
** Spelling
We all make mistakes..
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun flyspell-check-next-highlighted-word ()
    "Custom function to spell check next highlighted word"
    (interactive)
    (flyspell-goto-next-error)
    (ispell-word)
    )

  ;; switch dictionaries
  (let ((langs '("english" "nederlands" "francais")))
    (setq lang-ring (make-ring (length langs)))
    (dolist (elem langs) (ring-insert lang-ring elem)))
  (defun my/cycle-ispell-languages ()
    "Cycles through a list of set languages"
    (interactive)
    (let ((lang (ring-ref lang-ring -1)))
      (ring-insert lang-ring lang)
      (ispell-change-dictionary lang)))
  (bind-key "<f7>" 'my/cycle-ispell-languages)

  ;; avoid message overload by printing every checked word
  (setq flyspell-issue-message-flag nil)

  (bind-key "<f8>" 'ispell-word)
  (bind-key "C-S-<f8>" 'flyspell-mode)
  (bind-key "C-M-<f8>" 'flyspell-buffer)
  (bind-key "C-<f8>" 'flyspell-check-previous-highlighted-word)
  (bind-key "M-<f8>" 'flyspell-check-next-highlighted-word)

#+END_SRC
*** TODO wcheck-mode
#+BEGIN_EXAMPLE emacs-lisp
;; Alternative spell check mode that checks visible buffer
;; https://github.com/tlikonen/wcheck-mode
(require 'wcheck-mode)


(setq wcheck-language-data
      '(("US English"
         (program . "/usr/local/bin/hunspell")
         (args "-l" "-d" "en_US")
         (action-program . "/usr/local/bin/hunspell")
         (action-args "-a" "-d" "en_US")
         (action-parser . wcheck-parser-ispell-suggestions))
        ;; ("Another language"
         ;; ...)))
))
#+END_EXAMPLE

** Coding
*** TODO code folding
salvaged from old config:
#+BEGIN_SRC emacs-lisp :tangle no
;; Fold the active region
(global-set-key (kbd "C-c C-f") 'fold-this-all)
(global-set-key (kbd "C-c C-F") 'fold-this)
(global-set-key (kbd "C-c M-f") 'fold-this-unfold-all)
#+END_SRC
*** JavaScript
**** Tern                                                        :mode:minor:
#+BEGIN_SRC emacs-lisp :tangle yes
  ;; Set up the location of the tern .el files
  (if is-osx
      (add-to-list 'load-path "~/.tern/emacs")
      (add-to-list 'load-path "/usr/local/lib/node_modules/tern/emacs"))

  (autoload 'tern-mode "tern.el" nil t)

  (req-package company-tern
    :require (company tern)
    :config (add-to-list 'company-backends 'company-tern))
#+END_SRC
**** general
#+BEGIN_SRC emacs-lisp :tangle yes
  ;; javascript (js2-mode)
  (req-package js2-mode
               :require
               (flycheck tern js2-refactor skewer-mode)
               :mode
               "\\.js\\'"
               :config
               (progn (add-hook 'js2-mode-hook 'flycheck-mode)
                      (add-hook 'js2-mode-hook (lambda () (tern-mode t)))
                      (add-hook 'js2-mode-hook 'skewer-mode)
                      ;; js2-refactor keybindings start with:
                      (js2r-add-keybindings-with-prefix "C-c C-m")))

  ;; (add-hook 'js2-mode-hook 'repl-toggle-mode)
  ;; (add-hook 'js2-mode-hook 'hs-minor-mode)
  ;; repeat for js3-mode /TODO there must be a better way to define these
#+END_SRC
**** json
#+BEGIN_SRC emacs-lisp :tangle yes
  ;; json
  (req-package json-mode)
  (add-hook 'json-mode-hook 'flycheck-mode)
#+END_SRC
*** web mode (html+)
#+BEGIN_SRC emacs-lisp :tangle no
      ;; web mode
      (req-package web-mode
                   :require
                   (emmet-mode flycheck)
                   :mode
                   "\\.html\\'"
                   ;; (list "\\.html\\'" "\\.txp\\'")
                   :init
                   (add-hook 'web-mode-hook 'emmet-mode)
                   (add-hook 'web-mode-hook 'flycheck-mode))

#+END_SRC
*** php
#+BEGIN_SRC emacs-lisp :tangle yes
  (add-to-list 'auto-mode-alist '("\\.php\\'" . php-mode))
  (add-hook 'php-mode-hook 'flycheck-mode)
#+END_SRC
*** python
#+BEGIN_SRC emacs-lisp :tangle no
  ;; python
  (req-package jedi)
  (add-hook 'python-mode-hook 'auto-complete-mode)
  (add-hook 'python-mode-hook 'jedi:setup)
  (add-hook 'python-mode-hook 'flycheck-mode)
  (add-hook 'python-mode-hook (lambda () (interactive) (column-marker-3 81)))
#+END_SRC
*** puppet
#+BEGIN_SRC emacs-lisp :tangle yes
  ;; puppet mode
  (req-package puppet-mode
               :mode "\\.pp\\'")

#+END_SRC
*** yaml
#+BEGIN_SRC emacs-lisp :tangle yes
  (add-hook 'yaml-mode-hook 'flycheck-mode)
#+END_SRC
*** shell

    Flyscheck can use [[http://www.shellcheck.net/][shellcheck]] as a checker. Make sure it is installed on your system.

#+BEGIN_EXAMPLE sh
sudo pacman -S shellcheck
#+END_EXAMPLE

#+BEGIN_SRC emacs-lisp :tangle yes
  (add-hook 'sh-mode-hook 'flycheck-mode)
#+END_SRC
*** processing

C-c C-p r    Run a sketch.
C-c C-p b    Compile a sketch into .class files.
C-c C-p p    Run a sketch full screen.
C-c C-p e    Export sketch.
C-c C-p d    Find in reference.
C-c C-p f    Find or create sketch.
C-c C-p s    Search in Processing forum.

#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package processing-mode
    :config
    (setq processing-location "/usr/share/processing/processing-java")
    (setq processing-application-dir "/usr/share/processing/processing")
    (setq processing-sketchbook-dir "~/Code/processing")
    :mode "\\.pde\\'")
#+END_SRC

** Search
*** Ag
The silver searches is nice and fast for searching inside code repos
#+BEGIN_SRC emacs-lisp :tangle yes
  (if (executable-find "ag")
      (req-package ag))
#+END_SRC
** Major modes

*** comint-mode                                                  :mode:major:
    Comint-mode is a major mode for interaction with an inferior interpreter.
    Shells etc use comint mode.
    When the buffer gets large, emacs gets slow, we'll truncate when new lines are added
    #+BEGIN_SRC emacs-lisp :tangle yes
      ;; truncate comint buffers after x lines
      (setq comint-buffer-maximum-size 5000)
      (add-hook 'comint-output-filter-functions 'comint-truncate-buffer)
    #+END_SRC

*** Org                                                          :mode:major:
**** Org interaction

#+BEGIN_SRC emacs-lisp :tangle yes
  ;; org-mode: Don't ruin S-arrow to switch windows please (use M-+ and M-- instead to toggle)
  (setq org-replace-disputed-keys t)

  ;; follow links on RET (otherwise use C-c C-o)
  (setq org-return-follows-link t)

  ;; Fontify org-mode code blocks
  (setq org-src-fontify-natively t)

  ;; Tell me when editing stuff I can't see
  (setq org-catch-invisible-edits (quote show-and-error))

  ;; keybindings!
  (global-set-key (kbd "C-c l") 'org-store-link)
  ;; insert them in to org mode using C-c C-l
  (global-set-key (kbd "C-c c") 'org-capture)
  (global-set-key (kbd "C-c a") 'org-agenda)
  (global-set-key (kbd "C-c b") 'org-iswitchb)
#+END_SRC

**** File config
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq org-agenda-files '("~/Dropbox/org" "~/.emacs.d"))

  (setq org-directory "~/Dropbox/org")

  ;; Set default file for org-capture
  (setq org-default-notes-file (concat org-directory "/notes.org"))

  ;; MobileOrg
  (setq org-mobile-directory "~/Dropbox/mobileOrg")
  (setq org-mobile-files '(org-agenda-files
                           "~/Dropbox/org/trickle.org"))
  (setq org-mobile-inbox-for-pull "~/Dropbox/org/from-mobile.org")
#+END_SRC

**** Visuals

***** bullets

      A nicer way to represent hierarchy
      #+BEGIN_SRC emacs-lisp :tangle yes
        (require 'org-bullets)
        (setq org-bullets-bullet-list '("◉" "○" "✸"))
        (add-hook 'org-mode-hook (lambda () (org-bullets-mode 1)))
      #+end_src

**** Tasks and States

Borrowing heavily from [[http://doc.norang.ca/org-mode.html#TasksAndStates][norang.ca]]

A global set of TODO keywords

#+BEGIN_SRC emacs-lisp :tangle yes
  (setq org-todo-keywords
        (quote ((sequence "TODO(t)" "NEXT(n)" "BUSY(b)" "|" "DONE(d)")
                (sequence "WAITING(w@/!)" "HOLD(h@/!)" "|" "CANCELLED(c@/!)" "PHONE" "MEETING"))))

#+end_src

**** Capture templates

Define some capture templates

#+BEGIN_SRC emacs-lisp :tangle yes
  (setq org-capture-templates
        (quote (("t" "todo" entry (file "~/Dropbox/org/refile.org")
                 "* TODO %?\n%U\n%a\n" :clock-in t :clock-resume t)
                ("r" "respond" entry (file "~/Dropbox/org/refile.org")
                 "* NEXT Respond to %:from on %:subject\nSCHEDULED: %t\n%U\n%a\n" :clock-in t :clock-resume t :immediate-finish t)
                ("n" "note" entry (file "~/Dropbox/org/refile.org")
                 "* %? :NOTE:\n%U\n%a\n" :clock-in t :clock-resume t)
                ("a" "interesting app" entry (file "~/Dropbox/org/interesting_apps.org")
                 "* %? \n" :clock-in t :clock-resume t)
                ("j" "Journal" entry (file+datetree "~/Dropbox/org/diary.org")
                 "* %?\n%U\n" :clock-in t :clock-resume t)
                ("w" "org-protocol" entry (file "~/Dropbox/org/refile.org")
                 "* TODO Review %c\n%U\n" :immediate-finish t)
                ("m" "Meeting" entry (file "~/Dropbox/org/refile.org")
                 "* MEETING with %? :MEETING:\n%U" :clock-in t :clock-resume t)
                ("p" "Phone call" entry (file "~/Dropbox/org/refile.org")
                 "* PHONE %? :PHONE:\n%U" :clock-in t :clock-resume t)
                ("h" "Habit" entry (file "~/Dropbox/org/refile.org")
                 "* NEXT %?\n%U\n%a\nSCHEDULED: %(format-time-string \"%<<%Y-%m-%d %a .+1d/3d>>\")\n:PROPERTIES:\n:STYLE: habit\n:REPEAT_TO_STATE: NEXT\n:END:\n"))))

#+end_src

Sometimes empty logbook drawers are created.

#+BEGIN_SRC emacs-lisp :tangle yes
;; Remove empty LOGBOOK drawers on clock out
(defun bh/remove-empty-drawer-on-clock-out ()
  (interactive)
  (save-excursion
    (beginning-of-line 0)
    (org-remove-empty-drawer-at "LOGBOOK" (point))))

(add-hook 'org-clock-out-hook 'bh/remove-empty-drawer-on-clock-out 'append)
#+end_src


**** Babel

Org-babel allows you to add src blocks etc.

The code in SRC blocks can be evaluated, languages have to be permitted though.
#+BEGIN_SRC emacs-lisp :tangle yes
  (org-babel-do-load-languages
     'org-babel-load-languages
     '((js . t)
       (sh . t)
       (org . t)
       (python . t)
       (ditaa . t)
       (plantuml . t)))
#+END_SRC

plantuml also needs to know where to find the jar

#+BEGIN_SRC emacs-lisp :tangle yes
  (setq org-plantuml-jar-path "/opt/plantuml/plantuml.jar")
#+end_src

**** export

***** Activate built-in backends

#+BEGIN_SRC emacs-lisp :tangle yes
(setq org-export-backends '(ascii html icalendar latex md))
#+end_src

***** from =/contrib=

****** reveal.js
       [[https://github.com/yjwen/org-reveal/][github]]

       #+BEGIN_SRC emacs-lisp :tangle yes
         (require 'ox-reveal)
       #+end_src

**** TODO org-download
Drag and drop images to org-mode
[[https://github.com/abo-abo/org-download][github]] / [[https://www.youtube.com/watch?v%3DdAojpHR-6Uo][youtube demo]]
**** TODO org-beautify-theme
Prettify org buffers
[[https://github.com/jonnay/emagicians-starter-kit/blob/master/themes/org-beautify-theme.org][github]] / [[http://www.jonnay.net/bloggity-blog/2014/12/29_making-org-mode-typography-suck-a-little-less.html][blogpost]]
**** some help
***** helm-orgcard
Browse the orgcard with helm

#+BEGIN_SRC emacs-lisp :tangle yes
    (req-package helm-orgcard
      :require helm)
#+end_src

*** weechat                                                      :mode:major:
Weechat needs to be running.
Switched to erc though. This is just for reference
#+BEGIN_SRC emacs-lisp :tangle no
  ;; good source: https://github.com/the-kenny/.emacs.d/blob/master/site-start.d/weechat.el
  (req-package weechat
               :config
               (progn (setq weechat-modules '(weechat-button
                                              weechat-complete
                                              weechat-tracking
                                              ;;weechat-notifications
                                              )
                            weechat-host-default "localhost"
                            weechat-port-default 9000
                            weechat-mode-default 'plain
                            weechat-color-list
                            '(unspecified "black" "dark gray" "dark red" "red"
                                          "dark green" "light green" "brown"
                                          "yellow" "RoyalBlue3"
                                          "light blue"
                                          "dark magenta" "magenta" "dark cyan"
                                          "light cyan" "gray" "white")
                            weechat-prompt "> "
                            ;; weechat-notification-mode t
                            weechat-auto-monitor-buffers '("highmon" "#trickle")
                            weechat-complete-nick-ignore-self nil
                            weechat-button-buttonize-nicks nil
                            weechat-tracking-types '(:highlight (".+#trickle" . :message))
                            weechat-sync-active-buffer t
                            )
                      ;;(require 'gnutls)
                      ;;(add-to-list 'gnutls-trustfiles (expand-file-name (concat user-emacs-directory "/relay.crt")))
                      (set-face-background 'weechat-highlight-face "dark red")
                      (set-face-foreground 'weechat-highlight-face "light grey")
                      (add-hook 'weechat-mode-hook 'visual-line-mode)
                      ;; (add-hook 'weechat-mode-hook (lambda nil (load-theme-buffer-local 'tango (current-buffer))))
                      (tracking-mode)
                      ))

#+END_SRC
*** IRC
**** ERC and ZNC
I'm using ERC to connect to a znc server.
The =znc-servers= variable is set from a private el file'
#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package znc
               :commands (znc-erc znc-all)
               :require
               erc-hl-nicks
               :config
               (my/load-secrets "erc")
               ;; modules..
               (setq erc-modules '(autojoin
                                   button
                                   completion
                                   fill
                                   irccontrols
                                   keep-place
                                   list
                                   match
                                   menu
                                   move-to-prompt
                                   netsplit
                                   networks
                                   noncommands
                                   ;; notifications
                                   readonly
                                   ring
                                   scrolltobottom
                                   smiley
                                   stamp
                                   track))
               (add-hook 'erc-mode-hook 'erc-hl-nicks-mode)
               (add-hook 'erc-mode-hook 'visual-line-mode)
               (setq erc-timestamp-only-if-changed-flag nil ;; always timestamp
                     erc-timestamp-format "%H:%M:%S "
                     erc-fill-prefix nil ;; don't force indentation
                     erc-insert-timestamp-function 'erc-insert-timestamp-left ;; put the timestamp left
                     erc-hide-list '("JOIN" "PART" "QUIT") ;; hide pesky stuff
                     erc-input-line-position -1
                     erc-prompt ">"
                     erc-current-nick-highlight-type (quote all) ;; highlight full message to me
                     erc-fill-column 85
                     ;; matches
                     ;;erc-text-matched-hook '(erc-log-matches
                     ;;                        erc-terminal-notifier-text-matched)
                     erc-match-exclude-server-buffer t ;; don't bother matching the server buffer
                     ;; log matches
                     erc-log-matches-flag t ;; log mentions and keywords in their own buffer
                     erc-log-matches-types-alist '((keyword . "#ERC Keywords")
                                                   (current-nick . "#ERC Mentions"))
                     )

               (make-variable-buffer-local 'erc-fill-column)
               (add-hook 'window-configuration-change-hook
                         '(lambda ()
                            (save-excursion
                              (walk-windows
                               (lambda (w)
                                 (let ((buffer (window-buffer w)))
                                   (set-buffer buffer)
                                   (when (eq major-mode 'erc-mode)
                                     (setq erc-fill-column (- (window-width w) 2))))))))))

#+END_SRC
*** Mail
**** general
***** citation
 #+BEGIN_SRC emacs-lisp :tangle yes
   ;; On this date X wrote
   (setq message-citation-line-format "On %A %Y-%m-%d %T %Z, %f wrote:\n")
   (setq message-citation-line-function 'message-insert-formatted-citation-line)
 #+END_SRC
**** mu4e
#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package mu4e
      :require async
      :load-path "/usr/share/emacs/site-lisp/mu4e"
      :commands mu4e
      :config
      (my/load-secrets "mu4e")
#+END_SRC
***** paths and files

Basic mu4e setup: paths to binaries and where to find and put files.

#+BEGIN_SRC emacs-lisp :tangle yes
  ;; use mu4e as default mailclient
  (setq mail-user-agent 'mu4e-user-agent ;; default mail client
        ;; osx
        ;;mu4e-mu-binary "/usr/local/bin/mu"
        ;;mu4e-get-mail-command "~/bin/offlineimap/offlineimap.py"
        mu4e-mu-binary "/usr/bin/mu"
        mu4e-get-mail-command "offlineimap"
        mu4e-update-interval 600
        mu4e-maildir "~/Maildir"
        mu4e-attachment-dir  "~/Downloads/mail-attachments"
        mu4e-action-tags-header "X-Keywords" ;; thanks to offlineimap gmail
        mu4e-attachment-dir "~/Downloads")
#+END_SRC

***** visual

#+BEGIN_SRC emacs-lisp :tangle yes
  (add-hook 'mu4e-view-mode-hook 'window-margin-mode)

  ;; enable inline images
  (setq mu4e-view-show-images t
        mu4e-view-image-max-width 400)
  ;; use imagemagick, if available
  (when (fboundp 'imagemagick-register-types)
    (imagemagick-register-types))

  (setq mu4e-headers-fields '((:human-date . 15) (:flags . 4) (:mailing-list . 8) (:from-or-to . 22) (:thread-subject))
        mu4e-headers-date-format "%a %y/%m/%d %p"
        mu4e-headers-time-format "%T")

  ;; show full email
  (setq mu4e-view-show-addresses t)

  ;; do not spam the minibuffer about updates
  (setq mu4e-hide-index-messages t)
#+END_SRC

****** fancy chars

mu4e can use fancy characters in the header view

#+BEGIN_SRC emacs-lisp :tangle yes
  ;; use fancy characters for marks only, not the threading
  (setq mu4e-use-fancy-chars 'marks)
#+END_SRC

But they are not really that nice, especially the threading stuff.

Fixed in 0.9.13

#+BEGIN_SRC emacs-lisp :tangle no
  (when (and (eq t mu4e-use-fancy-chars)
             (member "FontAwesome" (font-family-list)))
  ;; marks for headers of the form; each is a cons-cell (basic . fancy)
  ;; each of which is basic ascii char and something fancy, respectively
        ;; (setq mu4e-headers-draft-mark     (purecopy '("D" . "⚒")) ;"Draft.")
            ;; mu4e-headers-flagged-mark   (purecopy '("F" . "⚑")) ;"Flagged.")
            ;; mu4e-headers-new-mark       (purecopy '("N" . "⭑")) ;"New.")
            ;; mu4e-headers-passed-mark    (purecopy '("P" . "")) ;"Passed (fwd).")
            ;; mu4e-headers-replied-mark   (purecopy '("R" . "")) ; Replied
            ;; mu4e-headers-seen-mark      (purecopy '("S" . "✔")) ;"Seen.")
            ;; mu4e-headers-trashed-mark   (purecopy '("T" . "♻")) ;"Trashed.")
            ;; mu4e-headers-attach-mark    (purecopy '("a" . "")) ; W/ attachments
            ;; mu4e-headers-encrypted-mark (purecopy '("x" . "⚴")) ;"Encrypted.") 
            ;; mu4e-headers-signed-mark    (purecopy '("s" . "☡")) ;"Signed.") 
            ;; mu4e-headers-unread-mark    (purecopy '("u" . "☐")) ;"Unread.")

            ;; thread prefix marks
    (setq  mu4e-headers-has-child-prefix    (purecopy '("+"  . "+"))  ;"Parent.")
           mu4e-headers-empty-parent-prefix (purecopy '("-"  . "-"))  ;"Orphan.")
           mu4e-headers-first-child-prefix  (purecopy '("\\" . "\\")) ;"First child.")
           mu4e-headers-duplicate-prefix    (purecopy '("="  . "="))  ;"Duplicate.")
           mu4e-headers-default-prefix       (purecopy '("|"  . "|")))) ;"Default."
#+END_SRC

****** html to text conversion

A very basic html stripper

#+BEGIN_SRC emacs-lisp :tangle yes
  ;; convert html messages
  (setq mu4e-html2text-command "w3m -dump -T text/html")
#+END_SRC

Emacs 24.4 added shr.el, which does a better job at showing HTML.
(It is also used in eww). It does feel a bit slow though

#+BEGIN_SRC emacs-lisp :tangle no
  (require 'mu4e-contrib)
  (setq mu4e-html2text-command 'mu4e-shr2text)
#+END_SRC

But I prefer to read text emails...

#+BEGIN_SRC emacs-lisp :tangle yes
  (setq mu4e-view-prefer-html nil)
#+end_src

***** behaviour
#+BEGIN_SRC emacs-lisp :tangle yes
  ;; don't save message to Sent Messages, Gmail/IMAP takes care of this
  (setq mu4e-sent-messages-behavior 'delete)

  ;; don't keep message buffers around when exiting mu4e
  (setq message-kill-buffer-on-exit t)

  ;; Strip addresses from mu4e-user-mail-address-list when replying.
  (setq mu4e-compose-dont-reply-to-self t)

  ;; apply marks when leaving headers buffer
  (setq mu4e-headers-leave-behavior 'apply)

  ;; Spellcheck FTW
  (add-hook 'mu4e-compose-mode-hook 'flyspell-mode)

#+END_SRC
****** scrolling the headers
When the buffer "*mu4e-view" is visible and you move to the next or previous message,
the headers will follow, but not in a smooth-scrolling way

This is a little workaround to make that happen. (the value on recenter does not work
as advertised)
This could probably be made a bit more DRY.

inspired by this email thread [[mu4e:msgid:87tx4g1n8a.fsf@gmail.com][Re: {Got} nice scrolling behaviour in header view]]

#+BEGIN_SRC emacs-lisp :tangle yes
(defadvice mu4e-view-headers-next (around scroll-down-mu4e-header activate)
  "Recenter the mu4e-header window around the visible header when moving onto
next email"
  (with-selected-window (get-buffer-window mu4e~headers-buffer t) (recenter 1))
  ad-do-it)

(defadvice mu4e-view-headers-prev (around scroll-up-mu4e-header activate)
  "Recenter the mu4e-header window around the visible header when moving onto
previous email"
  (with-selected-window (get-buffer-window mu4e~headers-buffer t) (recenter -1))
  ad-do-it)
#+END_SRC

***** crypto
epa-mail-mode allows you to:
- C-c C-e e :: encrypt
- C-c C-e s :: sign
#+BEGIN_SRC emacs-lisp :tangle yes

  (setq mu4e-auto-retrieve-keys t)
  (add-hook 'mu4e-compose-mode-hook 'epa-mail-mode)
  ;; (add-hook 'mu4e-view-mode-hook 'epa-mail-mode)

#+end_src

***** maildirs

I'm currently using offlineimap to sync all mail and then use tags (also see [[*tags][tags]])
So this is just for reference:

#+BEGIN_SRC emacs-lisp :tangle no
  ;; (setq mu4e-maildir-shortcuts
  ;;      '( (my/mu4e-maildir-pers . ?j)
  ;;         (my/mu4e-maildir-pro . ?t)))
#+END_SRC

***** bookmarks

#+BEGIN_SRC emacs-lisp :tangle yes
  (add-to-list 'mu4e-bookmarks '("tag:\\\\Sent and date:1w..now" "Sent this week" ?s))
  (add-to-list 'mu4e-bookmarks '("flag:unread and date:today..now" "Today's unread messages" ?d))
  (add-to-list 'mu4e-bookmarks '("tag:\\\\Inbox and date:today..now" "Today's inbox" ?n))
  (add-to-list 'mu4e-bookmarks '("tag:\\\\Inbox" "Unified inbox" ?I))
  (add-to-list 'mu4e-bookmarks '("tag:-Social" "Category Social" ?S) t)
  (add-to-list 'mu4e-bookmarks '("tag:-Promotions" "Category Promotions" ?P) t)
  (add-to-list 'mu4e-bookmarks '("tag:-Updates" "Category Updates" ?U) t)
  (add-to-list 'mu4e-bookmarks '("tag:-Forums" "Category Forums" ?F) t)
  (add-to-list 'mu4e-bookmarks '("tag:\\\\Inbox NOT tag:-Social NOT tag:-Forums NOT tag:-Updates NOT tag:-Promotions" "Unified inbox Clean" ?i))
  (add-to-list 'mu4e-bookmarks '("flag:flagged" "Flagged" ?+))
#+END_SRC

***** actions

#+BEGIN_SRC emacs-lisp :tangle yes
  (add-to-list 'mu4e-view-actions
               '("retag-message" . mu4e-action-retag-message) t)
  (add-to-list 'mu4e-headers-actions
               '("retag-message" . mu4e-action-retag-message) t)

  (defun my/mu4e-action-archive-message (msg)
    (mu4e-action-retag-message msg "-\\Inbox"))

  (defun my/mu4e-action-trash-message (msg)
    (mu4e-action-retag-message msg "-\\Inbox +\\Trash"))
      ;;(mu4e~proc-move docid nil  "+T-N"))

  ;; TODO: look in to mu4e-mark-execute-all
  ;; TODO: check if tags are gmail tags before executing
  ;; this would probably be better if executed by mu4e-mark-execute-all
  (defun my/mu4e-action-all-marked (ignored)
    (mu4e-headers-for-each
     (lambda (msg)
       (let ((docid (mu4e-message-field msg :docid)))
        (when (mu4e-mark-docid-marked-p docid)
          (my/mu4e-action-trash-message msg))))))

  (add-to-list 'mu4e-headers-actions
               '("xtrash all marked" . my/mu4e-action-all-marked) t)
  (add-to-list 'mu4e-view-actions
               '("xtrash all marked" . my/mu4e-action-all-marked) t)


  (add-to-list 'mu4e-view-actions
               '("earchive-message" . my/mu4e-action-archive-message) t)
  (add-to-list 'mu4e-headers-actions
               '("earchive-message" . my/mu4e-action-archive-message) t)
  (add-to-list 'mu4e-view-actions
               '("trash message" . my/mu4e-action-trash-message) t)
  (add-to-list 'mu4e-headers-actions
               '("trash message" . my/mu4e-action-trash-message) t)
  (add-to-list 'mu4e-view-actions
               '("View in browser" . mu4e-action-view-in-browser) t)
#+END_SRC

****** TODO fix trashing

***** composing

#+BEGIN_SRC emacs-lisp :tangle yes
  (defun my/mu4e-set-account ()
    "Set the account for composing a new message."
    (let* ((account
            (if mu4e-compose-parent-message
                (let ((maildir (mu4e-message-field mu4e-compose-parent-message :maildir)))
                  (string-match "/\\(.*?\\)/" maildir)
                  (match-string 1 maildir))
              (completing-read (format "Compose with account: (%s) "
                                       (mapconcat #'(lambda (var) (car var)) my/mu4e-account-alist "/"))
                               (mapcar #'(lambda (var) (car var)) my/mu4e-account-alist)
                                       nil t nil nil (caar my/mu4e-account-alist))))
            (account-vars (cdr (assoc account my/mu4e-account-alist))))
           (if account-vars
               (mapc #'(lambda (var)
                         (set (car var) (cadr var)))
                     account-vars)
             (error "No email account found"))))

  (add-hook 'mu4e-compose-pre-hook 'my/mu4e-set-account)
#+END_SRC

***** sending

Mail can be sent synchronously or asynchronously.
Going with synchronous for now.

Also, make sure gnutls are installed (for signing/encrypting messages)

#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'smtpmail)
  ;;(require 'smtpmail-async)
  (setq ;; send-mail-function 'async-smtpmail-send-it
        ;; message-send-mail-function 'async-smtpmail-send-it
        message-send-mail-function 'smtpmail-send-it
        starttls-use-gnutls t
        smtpmail-starttls-credentials '(("smtp.gmail.com" 587 nil nil))
        smtpmail-auth-credentials
        '(("smtp.gmail.com" 587 my/smtpmail-address nil))
        smtpmail-default-smtp-server "smtp.gmail.com"
        smtpmail-smtp-server "smtp.gmail.com"
        smtpmail-smtp-service 587
        ;; message queue for offline sending
        smtpmail-queue-mail nil ;; start in non-queueing mode
        smtpmail-queue-dir "~/Maildir/queue/cur"
        )

  ;; alternatively, for emacs-24 you can use:
  ;;(setq message-send-mail-function 'smtpmail-send-it
  ;;     smtpmail-stream-type 'starttls
  ;;     smtpmail-default-smtp-server "smtp.gmail.com"
  ;;     smtpmail-smtp-server "smtp.gmail.com"
  ;;     smtpmail-smtp-service 587)
#+END_SRC

***** mu4e and org
Enabling this allows you to store links to mail messages in org mode files.

#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'org-mu4e)

#+end_src

***** mu4e notifications
#+BEGIN_SRC emacs-lisp :tangle yes
(mu4e-alert-set-default-style 'libnotify)
(add-hook 'after-init-hook #'mu4e-alert-enable-notifications)
#+end_src

***** close req-package
#+BEGIN_SRC emacs-lisp :tangle yes
)
#+END_SRC

***** some inspiration
http://pablo.rauzy.name/dev/init.el.html
https://github.com/magnars/.emacs.d/blob/c1a481c9ba85ab3127bb77c7b60689abbbeb5611/setup-mu4e.el
https://github.com/agpchil/mu4e-maildirs-extension
https://bitbucket.org/seanfarley/dotfiles/src/69cbcf0dd9d6cb2c7aaa18e7a196315035ad4181/emacs/init/mail.el?at=default

reference
https://github.com/djcb/mu/blob/master/mu4e/mu4e-actions.el

****** TODO org and mu4e
[[mu4e:msgid:m2pphdpjyc.fsf@gmail.com][yet another mu4e/org solution]]
***** TODO mail attachments with dired
#+BEGIN_EXAMPLE emacs-lisp
;; Attach files via dired
;; mark, C-c RET C-a
;; from http://www.djcbsoftware.nl/code/mu/mu4e/Attaching-files-with-dired.html#Attaching-files-with-dired

(require 'gnus-dired)

;; make the `gnus-dired-mail-buffers' function also work on
;; message-mode derived modes, such as mu4e-compose-mode
(defun gnus-dired-mail-buffers ()
  "Return a list of active message buffers."
  (let (buffers)
    (save-current-buffer
      (dolist (buffer (buffer-list t))
        (set-buffer buffer)
     	(when (and (derived-mode-p 'message-mode)
                   (null message-sent-message-via))
     	  (push (buffer-name buffer) buffers))))
    (nreverse buffers)))

(setq gnus-dired-mail-mode 'mu4e-user-agent)
(add-hook 'dired-mode-hook 'turn-on-gnus-dired-mode)
#+END_EXAMPLE
**** reading mail
Set xdg to open *.eml files with emacs
#+BEGIN_SRC sh
xdg-mime default emacs.desktop message/rfc822
#+END_SRC

 and then


#+BEGIN_SRC emacs-lisp :tangle yes
  (add-to-list 'auto-mode-alist '("\\.eml$" . mail-mode))
#+END_SRC

** Minor modes
*** ido                                                          :mode:minor:
#+BEGIN_SRC emacs-lisp :tangle yes
    (req-package ido
                 :require
                 (flx flx-ido ido-vertical-mode ido-ubiquitous ido-at-point)
                 :init
                 (progn (ido-mode t)
                        (flx-ido-mode t)
                        (ido-vertical-mode)
                        (ido-at-point-mode)
                        (ido-ubiquitous-mode t))
                 :config
                 (setq ido-enable-flex-matching t
                       ido-case-fold nil
                       ido-auto-merge-work-directories-length 5
                       ido-create-new-buffer 'always
                       ido-use-filename-at-point nil
                       ido-max-prospects 10
                       ido-use-faces nil
                       ido-vertical-define-keys 'C-n-C-p-up-down-left-right)
                 :bind
                 ("C-x M-f" . ido-find-file-other-window))
#+END_SRC

*** editorconfig                                                 :mode:minor:
#+BEGIN_QUOTE
EditorConfig helps developers define and maintain consistent coding styles between different editors and IDEs. The EditorConfig project consists of a file format for defining coding styles and a collection of text editor plugins that enable editors to read the file format and adhere to defined styles. EditorConfig files are easily readable and they work nicely with version control systems.
#+END_QUOTE
More info on the [[http://editorconfig.org/][editorconfig website]].

You will need to put an (or more) /.editorconfig/ file in your dirs
And editorconfig-core needs to be installed
#+BEGIN_EXAMPLE .editorconfig
# EditorConfig is awesome: http://EditorConfig.org

# top-most EditorConfig file
root = true

# Unix-style newlines with a newline ending every file
[*]
end_of_line = lf
insert_final_newline = true

# 4 space indentation
[*.py]
indent_style = space
indent_size = 4

# Tab indentation (no size specified)
[*.js]
indent_style = tab

# Indentation override for all JS under lib directory
[lib/**.js]
indent_style = space
indent_size = 2

# Matches the exact files either package.json or .travis.yml
[{package.json,.travis.yml}]
indent_style = space
indent_size = 2
#+END_EXAMPLE

#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package editorconfig)
  (require 'editorconfig)
  (load "editorconfig")
#+END_SRC

*** helm

Helm is an incremental completion and selection framework for emacs.
Read more here: http://emacs-helm.github.io/helm/

Helm autoresize heights are set in percentages. If set to the same
amount, the helm buffer will be fixed size.

#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package helm-config
    :require (helm async helm-ag helm-swoop)
    :bind (("C-c h" . helm-command-prefix)
           ("M-x" . helm-M-x)
           ("M-y" . helm-show-kill-ring)
           ("C-x f" . helm-mini)
           ("C-x r b" . helm-bookmarks)
           ("C-x b" . helm-buffers-list))
    :config (progn (setq helm-M-x-fuzzy-match t
                         helm-recentf-fuzzy-match t
                         helm-semantic-fuzzy-match t
                         helm-imenu-fuzzy-match t
                         helm-buffers-fuzzy-matching t
                         helm-autoresize-max-height 40
                         helm-autoresize-min-height 10)
                   (global-set-key (kbd "C-c h o") 'helm-occur)
                   (global-set-key (kbd "C-c h SPC") 'helm-all-mark-rings)
                   (global-set-key (kbd "C-c h g") 'helm-do-ag)
                   (global-set-key (kbd "C-c h I") 'helm-swoop))
    :init (helm-autoresize-mode 1))
#+END_SRC

** Workspaces

*** Projectile                                                   :mode:minor:
#+BEGIN_SRC emacs-lisp :tangle yes
        (req-package projectile
          :require (helm helm-projectile)
          :config
            ;; C-c p a now opens other file with same name - but different extension
            ;; Add this to switch between js and html file
            (progn (add-to-list 'projectile-other-file-alist '("js" . ("html")))
                   (add-to-list 'projectile-other-file-alist '("html" . ("js"))))
          :init
          (projectile-global-mode)
          (helm-projectile-on))
#+END_SRC
**** Keybindings                                                :keybindings:
"C-c p" followed by a key
*** spaces                                                       :mode:minor:
#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package spaces)
#+END_SRC
** Bookmarks
I'm using the built in feature here
C-x r m : emacs maRk Make
C-x r l : emacs maRk list
C-x r b : jump to bookmark -> Now opens helm-bookmarks (see helm config)
- s to save (otherwise the bookmark does not survive the session)
- enter to open
- o to open in new window
- D mark for removal
- x execute removal
- r rename current item
** Language specifics

*** html & css

**** Emmet                                                       :mode:minor:
#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package emmet-mode)
#+END_SRC

** PDF

*** PDF-tools

    PDF-tools is a package which provides a full pdf viewer/anotator in emacs.
    It is availble form Melpa and acitvated by doing

    #+BEGIN_SRC emacs-lisp :tangle yes
      (pdf-tools-install)
    #+end_src

    The different modes are fully documented (=M-x pdf-tools-help=),
    but here are some keybindings to get you started:

    - +,-,0 :: Zoom
    - P,H,W :: fit Page, Height, Width
    - B,N :: Back and Next in hostory

    - C-c C-a :: prefix for annotations
      - h :: highlight region
      - m :: markup region (choose between highlight and others)
      - t :: text annotation
      - l :: list annotation
      - D :: delete annotation

    - o :: outline (in outline =.= moves the mark to the current page)

**** error while loading shared libs

     You might get an error after updating poppler.

     #+NAME: epdfinfo error
     #+BEGIN_EXAMPLE
"Error running `/home/jeroen/.emacs.d/.cask/24.5.1/elpa/pdf-tools-20150716.643/epdfinfo': /home/jeroen/.emacs.d/.cask/24.5.1/elpa/pdf-tools-20150716.643/epdfinfo: error while loading shared libraries: libpoppler.so.55: cannot open shared object file: No such file or directory""
#+END_EXAMPLE

     To remedy, just remove the =epdfinfo= executable mentioned in the error and re-run =(pdf-tools-install)=

*** Interleave

    Org notes linked to pdf pages

    In an org document add the interleave heading linking to the pdf
    doc in question.

    #+BEGIN_SRC org
      #+INTERLEAVE_PDF: /the/path/to/pdf.pdf
    #+END_SRC

    Then to =M-x interleave= to open the pdf alongside and =i= to add a note to the current page.

** External services

*** Gist                                                         :mode:minor:
#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package gist)

#+END_SRC

*** ix (pastebin)
#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package ix)
#+END_SRC

** Notifications

*** TODO sauron
An emacs event log with weight
[[https://github.com/djcb/sauron][github]]

* The end
Do the req-package magic and load my file of secrets
#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package-finish)
#+END_SRC

* Fixing bugs

** 2015-01-16 discover.el messing with keybindings
see http://www.reddit.com/r/emacs/comments/2sbxun/help_undotreemode_eating_bindings/

solution: uncomment following lines from [[file:~/.emacs.d/.cask/24.4.1/elpa/discover-20140103.1339/discover.el][discover.el]]

#+BEGIN_EXAMPLE emacs-lisp
  ;;;Rectangles - C-x r ...
  368     ;;(rectangles nil nil "C-x r")
  369     ;; Isearch
  370     ;;(isearch nil nil "M-s")
#+END_EXAMPLE
