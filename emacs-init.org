* Emacs Org Configuration
* Description
This file is tangled by init.el using =org-babel-load-file=. What this does is generate a =emacs-init.el= from the =emacs-lisp= source blocks.
* Prerequisites
** git
** cask
An emacs package manager: http://cask.github.io/installation.html
* Package Management

[[https://github.com/rdallasgray/pallet][Pallet]] is a very helpful package management tool for Emacs. 
It utilizes a dependency management platform called [[https://github.com/cask/cask][Cask]], 
to update a centralized =Cask= file when you install or remove packages.

** Cask
Cask is initialized in =init.el= with the following:
#+BEGIN_SRC emacs-lisp :tangle no
(require 'cask "~/.cask/cask.el")
(cask-initialize)
#+END_SRC

** Pallet
You can download all packages in your =Cask= file by using =M-x pallet-install=.
However, this should not be necessary.

** Install Packages
- Install [[https://github.com/cask/cask][Cask]].
- Run =cask install= in =$HOME/.emacs.d/=.

* The config
** Dependency Management with =req-package=

Where Pallet keeps track of the packages we have installed, =req-package=
handles all our internal package dependencies and configurations.

#+BEGIN_QUOTE
[[https://github.com/edvorg/req-package][req-package]] is a wrapper on top of [[https://github.com/jwiegley/use-package][use-package]], a package dependency
management tool. The documentation for =use-package= is immensely helpful for
figuring out how to describe package dependencies and settings. =req-package=
adds the =:require= keyword which allows you to define dependencies between
related packages.
#+END_QUOTE

Start using =req-package=
#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'req-package)
  (req-package pallet)
#+END_SRC

** System
First find out wether we're working on OSX or not

#+BEGIN_SRC emacs-lisp :tangle yes
    ;; Are we on a mac?
    (setq is-osx (equal system-type 'darwin))

    ;; On OS X GUI applications do not inherit variables from the shell
    ;; configuration and thus have a different $PATH
    ;; test by doing "M-: (executable-find "flake8")"
    ;; C-h v exec-path
    (when is-osx (progn (req-package exec-path-from-shell)
                        (exec-path-from-shell-initialize)))
#+END_SRC
*** File Paths
#+BEGIN_SRC emacs-lisp :tangle yes
    ;; define some external to emacs paths
    (setq dropbox "~/Dropbox")

#+END_SRC
** Basics
   Some essential customizations.
*** The custom customizations

    Emacs let's you use the /customize/ interface to change things up.
    Using the following code we make sure everything gets put in and loaded from the correct file.

#+BEGIN_SRC emacs-lisp :tangle yes
    ;; Use a custom.el file for customizations and load it
    (setq custom-file (expand-file-name "custom.el"
                                        user-emacs-directory))
    (load custom-file)

#+END_SRC

*** The interface
**** Remove UI components
We defined earlier whether we are running on OSX. The variable =window-system= tells us in which window system we're running, if at all.

#+BEGIN_SRC emacs-lisp :tangle yes
    ;; Turn off mouse interface early in startup to avoid momentary display
    ;; menu can exist on osx when run as cocoa app
    (if (and is-osx (eq window-system "ns"))
        (if (fboundp 'menu-bar-mode) (menu-bar-mode t))
        (if (fboundp 'menu-bar-mode) (menu-bar-mode -1)))
    (if (fboundp 'tool-bar-mode) (tool-bar-mode -1))
    (if (fboundp 'scroll-bar-mode) (scroll-bar-mode -1))
#+END_SRC

**** Interface defaults
Some sensible defaults

#+BEGIN_SRC emacs-lisp :tangle yes
  ;; No splash screen
  (setq inhibit-startup-message t)

  ;; Full path in frame title
  (when window-system
    (setq frame-title-format '(buffer-file-name "%f" ("%b"))))

  ;; don't beep but flash the screen
  ;; font-lock-mode provides the colors for spec languages, set max fontification (1-3)
  ;; force color theme (no increments)
  ;; don't truncate on partial width
  (setq visible-bell t
        font-lock-maximum-decoration t
        color-theme-is-global t
        truncate-partial-width-windows nil)

  ;; Enable syntax highlighting for older Emacsen that have it off
  (global-font-lock-mode t)

  ;; Highlight current line
  (global-hl-line-mode 1)

  ;; Don't defer screen updates when performing operations
  (setq redisplay-dont-pause t)

  ;; Highlight matching parentheses when the point is on them.
  (show-paren-mode 1)

  (blink-cursor-mode -1)

  ;; Show active region
  (transient-mark-mode 1)
  (make-variable-buffer-local 'transient-mark-mode)
  (put 'transient-mark-mode 'permanent-local t)
  (setq-default transient-mark-mode t)


  ;; Show me empty lines after buffer end
  (set-default 'indicate-empty-lines t)

  ;; smaller cursor
  (setq cursor-type 'bar)

#+END_SRC  

**** Appearance
#+BEGIN_SRC emacs-lisp :tangle yes
  ;; easily switch between all themes
  (req-package themepark-mode)

  ;; the current theme of choice
  (load-theme 'tango t)

  ;; set the font
  (if is-osx
      (set-face-attribute 'default nil :family "source code pro" :weight "light")
      (set-default-font "SourceCodePro-10"))

#+END_SRC

**** Mode Line
#+BEGIN_SRC emacs-lisp :tangle yes
  (size-indication-mode t)

  (req-package smart-mode-line
               :config
               (progn (setq sml/theme 'automatic)
                      ;; replace common paths
                      (add-to-list 'sml/replacer-regexp-list '("^/Volumes/devHD/" "::"))
                      (add-to-list 'sml/replacer-regexp-list '("^~/dev/" "::"))

                      ;; hide minor modes
                      (add-to-list 'sml/hidden-modes " Projectile")
                      (add-to-list 'sml/hidden-modes " ,")
                      (add-to-list 'sml/hidden-modes " Guide"))
               :init
               (sml/setup))

#+END_SRC
**** Buffers
***** ibuffer
Start using ibuffer
#+BEGIN_SRC emacs-lisp :tangle yes
  ;; use ibuffer
  (bind-key "C-x C-b" 'ibuffer)
#+END_SRC
Here we sort the buffers for a nicer ibuffer view
#+BEGIN_SRC emacs-lisp :tangle yes
  ;; sort buffers
  (setq ibuffer-saved-filter-groups
        `(("default"
           ("emacs.d"
            (filename . "/.emacs.d/"))
           ("emacs"
            (or
             (name . "^\\*scratch\\*$")
             (name . "^\\*Messages\\*$")
             (name . "^\\*Help\\*$")
             (name . "^\\*Completions\\*$")
             (name . "^\\*Quail Completions\\*$")
             (name . "^\\*Packages\\*$")
             (name . "^\\*Backtrace\\*$")
             (name . "^\\*Compile-Log\\*$")))
           ("Code"
            (or
             (mode . c-mode)
             (mode . c++-mode)
             (mode . perl-mode)
             (mode . python-mode)
             (mode . ruby-mode)
             (mode . emacs-lisp-mode)
             (mode . lisp-mode)
             (mode . sh-mode)
             (mode . php-mode)
             (mode . xml-mode)
             (mode . html-mode)
             (mode . web-mode)
             (mode . css-mode)
             (mode . js-mode)
             (mode . js2-mode)
             (mode . js3-mode)))
           ("Mail"
            (or
             (mode . message-mode)
             (mode . mail-mode)
             (mode . mu4e-main-mode)
             (mode . mu4e-headers-mode)
             (mode . mu4e-view-mode)
             (mode . mu4e-compose-mode)))
           ("Chat"
            (or
             (mode . erc-mode)
             (name . "^\\#ERC Mentions$")
             (mode . identica-mode)
             (mode . twitter-mode)))
           ("Dired"
            (or
             (mode . dired-mode)
             (mode . direx-mode)))
           ("Org"
            (mode . org-mode))
           )))

  (setq ibuffer-show-empty-filter-groups nil)

  (add-hook 'ibuffer-mode-hook
            (lambda ()
              (ibuffer-switch-to-saved-filter-groups "default")))
#+END_SRC
****** TODO look in to ibuffer-vc.el
https://github.com/purcell/ibuffer-vc/blob/master/ibuffer-vc.el
***** windmove 
Lets you jump from one window to the next
#+BEGIN_SRC emacs-lisp :tangle yes
  ;; Move windows, even in org-mode
  (bind-key "<S-right>" 'windmove-right)
  (bind-key "<S-left>" 'windmove-left)
  (bind-key "<S-up>" 'windmove-up)
  (bind-key "<S-down>" 'windmove-down)
#+END_SRC
***** resizing
#+BEGIN_SRC emacs-lisp :tangle yes
  ;; window resizing
  (bind-key "S-C-<left>" 'shrink-window-horizontally)
  (bind-key "S-C-<right>" 'enlarge-window-horizontally)
  (bind-key "S-C-<down>" 'shrink-window)
  (bind-key "S-C-<up>" 'enlarge-window)
#+END_SRC
***** move buffers around
#+BEGIN_SRC emacs-lisp :tangle yes
  ;; move buffer to window
  (req-package buffer-move
               :bind
               ("<M-S-up>" . buf-move-up)
               ("<M-S-down>" . buf-move-down)
               ("<M-S-left>" . buf-move-left)
               ("<M-S-right>" . buf-move-right))
#+END_SRC  
  

*** General interaction and settings

**** Defaults
#+BEGIN_SRC emacs-lisp :tangle yes
  ;; Auto refresh buffers when edits occur outside emacs
  (global-auto-revert-mode 1)
  
  ;; Save point position between sessions
  (req-package saveplace
               :init
               (setq-default save-place t)
               :config
               (setq save-place-file (expand-file-name ".places" user-emacs-directory)))
  
  ;; this is disabled by default
  (put 'narrow-to-region 'disabled nil)
  
  ;; Save a list of recent files visited. (open recent file with C-x f)
  (recentf-mode 1)
  (setq recentf-max-saved-items 100) ;; just 20 is too recent
  
  ;; Undo/redo window configuration with C-c <left>/<right>
  (winner-mode 1)
  
  ;; Never insert tabs
  (set-default 'indent-tabs-mode nil)
  
  ;; Easily navigate sillycased words
  (global-subword-mode 1)
  
  ;; Don't break lines for me, please
  ;; This is nicer with 'visual-line-mode (and adaptive wrap)
  (setq-default truncate-lines t)
  
  ;; Keep cursor away from edges when scrolling up/down
  (req-package smooth-scrolling)
  
  ;; Allow recursive minibuffers
  ;; (setq enable-recursive-minibuffers t)
  
  ;; Don't be so stingy on the memory, we have lots now. It's the distant future.
  (setq gc-cons-threshold 20000000)
  
  ;; Represent undo-history as an actual tree (visualize with C-x u)
  (req-package undo-tree
               :init
               (global-undo-tree-mode)
               :config
               (setq undo-tree-mode-lighter ""))
  
  ;; Sentences do not need double spaces to end. Period.
  (set-default 'sentence-end-double-space nil)
  
  ;; Add parts of each file's directory to the buffer name if not unique
  ;; not available on MELPA
  (req-package uniquify
               :init
               (setq uniquify-buffer-name-style 'forward))
  
  ;; A saner ediff
  (setq ediff-diff-options "-w")
  (setq ediff-split-window-function 'split-window-horizontally)
  (setq ediff-window-setup-function 'ediff-setup-windows-plain)
  
  ;; Nic says eval-expression-print-level needs to be set to nil (turned off) so
  ;; that you can always see what's happening.
  (setq eval-expression-print-level nil)
  
  ;; When popping the mark, continue popping until the cursor actually moves
  ;; Also, if the last command was a copy - skip past all the expand-region cruft.
  (defadvice pop-to-mark-command (around ensure-new-position activate)
    (let ((p (point)))
      (when (eq last-command 'save-region-or-current-line)
        ad-do-it
        ad-do-it
        ad-do-it)
      (dotimes (i 10)
        (when (= p (point)) ad-do-it))))
  
  ;; Smart M-x : ido like interactivity for M-x
  ;; when ido-ubiquitous is used, smex is just used to keep
  ;; a history of last used commands.
  ;; TODO: check previous statement about smex and ido-ubiquitous
  (req-package smex
               :require ido
               :init
               (smex-initialize)
               :bind
               (("M-x" . smex)
                ("M-X" . smex-major-mode-commands)
                ("C-c C-c M-x" . execute-extended-command)))
  
  ;; Hide mousepointer when typing
  (setq make-pointer-invisible t)
  
  ;; erc made the pointer go off screen, forcing a recenter
  ;; oufo on #emacs suggested this: (works great)
  (setq scroll-conservatively 1000)
  
  ;; simple y or n questions
  (defalias 'yes-or-no-p 'y-or-n-p)
#+END_SRC

***** Backups
from: http://ergoemacs.org/emacs/emacs_set_backup_into_a_directory.html
This function will mirror all directories at the given backup dir. 
For example, if you are editing a file /Users/j/web/xyz/myfile.txt,
and your backup root is 
/Users/j/.emacs.d/emacs-backup/, then the backup will be at 
/Users/j/.emacs.d/emacs-backup/Users/j/web/xyz/myfile.txt~.

#+BEGIN_SRC emacs-lisp :tangle yes
  ;; make backup to a designated dir, mirroring the full path
  (defun my/backup-file-full-dir (fpath)
    "Return a new backup file path of a given file path.
  If the new path's directories does not exist, create them."
    (let* (
          (backupRootDir (expand-file-name
                   (concat user-emacs-directory "backups")))
          ;;(backupRootDir "~/.emacs.d/emacs-backup/")
          (filePath (replace-regexp-in-string "[A-Za-z]:" "" fpath )) ; remove Windows driver letter in path, ⁖ “C:”
          (backupFilePath (replace-regexp-in-string "//" "/" (concat backupRootDir filePath "~") ))
          )
      (make-directory (file-name-directory backupFilePath) (file-name-directory backupFilePath))
      backupFilePath
    )
  )
  
  ;; Actually set the backup dir now
  (setq make-backup-file-name-function 'my/backup-file-full-dir)
#+END_SRC
**** Better visual line mode
Visual line mode does not take indentation in to account. adaptive-wrap-prefix-mode solves that.
from: http://stackoverflow.com/a/13561223/1929897
#+BEGIN_SRC emacs-lisp :tangle yes 
  (req-package adaptive-wrap)
  
  (when (fboundp 'adaptive-wrap-prefix-mode)
    (defun my/activate-adaptive-wrap-prefix-mode ()
      "Toggle `visual-line-mode' and `adaptive-wrap-prefix-mode' simultaneously."
      (adaptive-wrap-prefix-mode (if visual-line-mode 1 -1)))
    (add-hook 'visual-line-mode-hook 'my/activate-adaptive-wrap-prefix-mode))
#+END_SRC
**** Smarter move to beginning of line
A nice function that knows where the business part of a line starts
from: http://emacsredux.com/blog/2013/05/22/smarter-navigation-to-the-beginning-of-a-line/

#+BEGIN_SRC emacs-lisp :tangle yes
  (defun my/smarter-move-beginning-of-line (arg)
    "Move point back to indentation of beginning of line.
  
  Move point to the first non-whitespace character on this line.
  If point is already there, move to the beginning of the line.
  Effectively toggle between the first non-whitespace character and
  the beginning of the line.
  
  If ARG is not nil or 1, move forward ARG - 1 lines first.  If
  point reaches the beginning or end of the buffer, stop there."
    (interactive "^p")
    (setq arg (or arg 1))
  
    ;; Move lines first
    (when (/= arg 1)
      (let ((line-move-visual nil))
        (forward-line (1- arg))))
  
    (let ((orig-point (point)))
      (back-to-indentation)
      (when (= orig-point (point))
        (move-beginning-of-line 1))))
  
  (bind-key "C-a" 'my/smarter-move-beginning-of-line)
#+END_SRC
**** (Un)comment region or line
from: http://stackoverflow.com/a/9697222/1929897
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun my/comment-or-uncomment-region-or-line ()
      "Comments or uncomments the region or the current line if there's no active region."
      (interactive)
      (let (beg end)
          (if (region-active-p)
              (setq beg (region-beginning) end (region-end))
              (setq beg (line-beginning-position) end (line-end-position)))
          (comment-or-uncomment-region beg end)
          (next-line)))
   (bind-key "C-c /" 'my/comment-or-uncomment-region-or-line)
#+END_SRC
**** popwin
Pop!
#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package popwin
               :init
               (popwin-mode t))
#+END_SRC
**** Some help
***** guide-key                                                  :mode:minor:
#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package guide-key
               :init
               (guide-key-mode 1)
               :config
               (setq guide-key/guide-key-sequence '("C-c p" ;; projectile
                                                    "C-c !" ;; flycheck
                                                    "C-x r" ;; ... stuff
                                                    "C-x 4" ;; file other window
                                                    "C-x v" ;; generic version controll
                                                    "C-x 8" ;; special chars
                                                    "C-x x" ;; persp
                                                    "H-x" ;; start apps
                                                    )
                     guide-key/recursive-key-sequence-flag t
                     guide-key/popup-window-position 'bottom))

#+END_SRC
**** expand-region                                               :mode:minor:
#+BEGIN_SRC emacs-lisp :tangle yes
    (req-package expand-region
                 :bind
                 ("C-=" . er/expand-region))
#+END_SRC

**** multiple-cursors                                            :mode:minor:
#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package multiple-cursors
               :bind
               (("C->" . mc/mark-next-like-this)
                ("C-<" . mc/mark-previous-like-this)
                ("C-c C-<" . mc/mark-all-like-this)
                ("C-c C->" . mc/edit-lines))) ;; adds a cursor to all lines in current region

#+END_SRC

**** smartparens                                                 :mode:minor:
#+BEGIN_SRC emacs-lisp :tangle yes
    (req-package smartparens-config
                 :require 
                 (smartparens)
                 :init
                 (smartparens-global-mode))

#+END_SRC

**** direx
Direx shows the dir or projects file structure.
We'll be using popwin to make it pop!
#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package direx
               :require
               (direx-project popwin)
               :init
               (push '(direx:direx-mode :position left :width 40 :dedicated t)
                            popwin:special-display-config)
               :bind
               ("C-x C-j" . direx-project:jump-to-project-root-other-window))
#+END_SRC
**** recent files
Find recent files
from: Magnars https://github.com/magnars/.emacs.d/blob/c1a481c9ba85ab3127bb77c7b60689abbbeb5611/defuns/buffer-defuns.el
#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package s)
  
  (defvar user-home-directory (concat (expand-file-name "~") "/"))
  
  (defun shorter-file-name (file-name)
    (s-chop-prefix user-home-directory file-name))
  
  (defun recentf--file-cons (file-name)
    (cons (shorter-file-name file-name) file-name))
  
  (defun recentf-ido-find-file ()
    "Find a recent file using ido."
    (interactive)
    (let* ((recent-files (mapcar 'recentf--file-cons recentf-list))
           (files (mapcar 'car recent-files))
           (file (completing-read "Choose recent file: " files)))
      (find-file (cdr (assoc file recent-files)))))
  
  (bind-key "C-x f" 'recentf-ido-find-file)
#+END_SRC
**** move and rename files & buffers
Small conveniece defuns by steveyegge2
https://sites.google.com/site/steveyegge2/my-dot-emacs-file
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun rename-file-and-buffer (new-name)
    "Renames both current buffer and file it's visiting to NEW-NAME." (interactive "sNew name: ")
    (let ((name (buffer-name))
          (filename (buffer-file-name)))
      (if (not filename)
          (message "Buffer '%s' is not visiting a file!" name)
        (if (get-buffer new-name)
            (message "A buffer named '%s' already exists!" new-name)
          (progn (rename-file name new-name 1)
                 (rename-buffer new-name)
                 (set-visited-file-name new-name)          
                 (set-buffer-modified-p nil))))))
  
  (defun move-file-and-buffer-to-dir (dir)
   "Moves both current buffer and file it's visiting to DIR." (interactive "DNew directory: ")
   (let* ((name (buffer-name))
          (filename (buffer-file-name))
           (dir
           (if (string-match dir "\\(?:/\\|\\\\)$")
           (substring dir 0 -1) dir))
           (newname (concat dir "/" name)))
  
     (if (not filename)
         (message "Buffer '%s' is not visiting a file!" name)
       (progn (copy-file filename newname 1)
              (delete-file filename)
              (set-visited-file-name newname)
              (set-buffer-modified-p nil)
              t)))) 
  
#+END_SRC
**** Quitting emacs
A little reworking of the default to close windows, but keep the deamon running.
And a way to effectively kill emacs
#+BEGIN_SRC emacs-lisp :tangle yes
  ;; define function to shutdown emacs server instance
  (defun my/server-stop ()
    "Save buffers, Quit, and Shutdown (kill) server"
    (interactive)
    (save-some-buffers)
    (kill-emacs)
    )
  
  ;; I don't need to kill emacs that easily
  ;; the mnemonic is C-x REALLY QUIT
  (bind-key "C-x r q" 'my/server-stop)
  (bind-key "C-x C-c" 'delete-frame)
#+END_SRC
** Git
*** magit                                                        :mode:major:
The git interface in emacs
#+BEGIN_SRC emacs-lisp :tangle yes
    (req-package magit
                 :bind
                 ("C-x m" . magit-status))
#+END_SRC
*** git-timemachine                                              :mode:major:
Allows you to walk though different versions of a file 
#+BEGIN_SRC emacs-lisp :tangle yes
    (req-package git-timemachine
                 :bind
                 ("C-x M" . git-timemachine))
#+END_SRC
** Spelling
We all make mistakes..
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun flyspell-check-next-highlighted-word ()
    "Custom function to spell check next highlighted word"
    (interactive)
    (flyspell-goto-next-error)
    (ispell-word)
    )
  
  ;; switch dictionaries
  (let ((langs '("english" "nederlands" "francais")))
    (setq lang-ring (make-ring (length langs)))
    (dolist (elem langs) (ring-insert lang-ring elem)))
  (defun my/cycle-ispell-languages ()
    "Cycles through a list of set languages"
    (interactive)
    (let ((lang (ring-ref lang-ring -1)))
      (ring-insert lang-ring lang)
      (ispell-change-dictionary lang)))
  (bind-key "<f7>" 'my/cycle-ispell-languages)
  
  ;; avoid message overload by printing every checked word
  (setq flyspell-issue-message-flag nil)
  
  (bind-key "<f8>" 'ispell-word)
  (bind-key "C-S-<f8>" 'flyspell-mode)
  (bind-key "C-M-<f8>" 'flyspell-buffer)
  (bind-key "C-<f8>" 'flyspell-check-previous-highlighted-word)
  (bind-key "M-<f8>" 'flyspell-check-next-highlighted-word)
  
#+END_SRC
** Major modes

*** comint-mode                                                  :mode:major:
    Comint-mode is a major mode for interaction with an inferior interpreter.
    Shells etc use comint mode.
    When the buffer gets large, emacs gets slow, we'll truncate when new lines are added
    #+BEGIN_SRC emacs-lisp :tangle yes
      ;; truncate comint buffers after x lines
      (setq comint-buffer-maximum-size 5000)
      (add-hook 'comint-output-filter-functions 'comint-truncate-buffer)
    #+END_SRC
    
*** Org                                                          :mode:major:
**** Org interaction
#+BEGIN_SRC emacs-lisp :tangle yes
  ;; org-mode: Don't ruin S-arrow to switch windows please (use M-+ and M-- instead to toggle)
  (setq org-replace-disputed-keys t)

  ;; Fontify org-mode code blocks
  (setq org-src-fontify-natively t)

  ;; Tell me when editing stuff I can't see
  (setq org-catch-invisible-edits (quote show-and-error))
#+END_SRC

**** File config
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq org-agenda-files '("~/Dropbox/org/notes.org"))
  
  (setq org-directory "~/Dropbox/org")
  
  ;; MobileOrg
  (setq org-mobile-directory "~/Dropbox/mobileOrg")
  (setq org-mobile-files '(org-agenda-files
                           "~/Dropbox/org/trickle.org"))
  (setq org-mobile-inbox-for-pull "~/Dropbox/org/from-mobile.org")
#+END_SRC
**** TODO Visuals
#+BEGIN_SRC emacs-lisp :tangle no
  ;; install then first...
  (setq org-ditaa-jar-path "/usr/local/Cellar/ditaa/0.9/libexec/ditaa0_9.jar")
  
  ;; osx
  ;; (setq org-plantuml-jar-path "/usr/local/Cellar/plantuml/7987/plantuml.7987.jar")
  (setq org-plantuml-jar-path "/opt/plantuml/plantuml.jar")
  
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((ditaa . t)
  
  ;; osx
  ;; (setq org-plantuml-jar-path "/usr/local/Cellar/plantuml/7987/plantuml.7987.jar")
  (setq org-plantuml-jar-path "/opt/plantuml/plantuml.jar")
  
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((ditaa . t)
     (plantuml . t)))
  
#+END_SRC
*** weechat                                                      :mode:major:
Weechat needs to be running.
Switched to erc though. This is just for reference
#+BEGIN_SRC emacs-lisp :tangle no
  ;; good source: https://github.com/the-kenny/.emacs.d/blob/master/site-start.d/weechat.el
  (req-package weechat
               :config
               (progn (setq weechat-modules '(weechat-button
                                              weechat-complete
                                              weechat-tracking
                                              ;;weechat-notifications
                                              )
                            weechat-host-default "localhost"
                            weechat-port-default 9000
                            weechat-mode-default 'plain
                            weechat-color-list
                            '(unspecified "black" "dark gray" "dark red" "red"
                                          "dark green" "light green" "brown"
                                          "yellow" "RoyalBlue3"
                                          "light blue"
                                          "dark magenta" "magenta" "dark cyan"
                                          "light cyan" "gray" "white")
                            weechat-prompt "> "
                            ;; weechat-notification-mode t
                            weechat-auto-monitor-buffers '("highmon" "#trickle")
                            weechat-complete-nick-ignore-self nil
                            weechat-button-buttonize-nicks nil
                            weechat-tracking-types '(:highlight (".+#trickle" . :message))
                            weechat-sync-active-buffer t
                            )
                      ;;(require 'gnutls)
                      ;;(add-to-list 'gnutls-trustfiles (expand-file-name (concat user-emacs-directory "/relay.crt")))
                      (set-face-background 'weechat-highlight-face "dark red")
                      (set-face-foreground 'weechat-highlight-face "light grey")
                      (add-hook 'weechat-mode-hook 'visual-line-mode)
                      ;; (add-hook 'weechat-mode-hook (lambda nil (load-theme-buffer-local 'tango (current-buffer))))
                      (tracking-mode)
                      ))

#+END_SRC
*** ERC
Emacs erc client
#+BEGIN_SRC emacs-lisp :tangle yes

#+END_SRC
** Minor modes
*** ido                                                          :mode:minor:
#+BEGIN_SRC emacs-lisp :tangle yes
    (req-package ido
                 :require
                 (flx flx-ido ido-vertical-mode ido-ubiquitous ido-at-point)
                 :init
                 (progn (ido-mode t)
                        (flx-ido-mode t)
                        (ido-vertical-mode)
                        (ido-at-point-mode)
                        (ido-ubiquitous-mode t))
                 :config
                 (setq ido-enable-flex-matching t
                       ido-case-fold nil
                       ido-auto-merge-work-directories-length 5
                       ido-create-new-buffer 'always
                       ido-use-filename-at-point nil
                       ido-max-prospects 10
                       ido-use-faces nil)
                 :bind
                 ("C-x M-f" . ido-find-file-other-window))
#+END_SRC

*** editorconfig                                                 :mode:minor:
#+BEGIN_QUOTE
EditorConfig helps developers define and maintain consistent coding styles between different editors and IDEs. The EditorConfig project consists of a file format for defining coding styles and a collection of text editor plugins that enable editors to read the file format and adhere to defined styles. EditorConfig files are easily readable and they work nicely with version control systems.
#+END_QUOTE
More info on the [[http://editorconfig.org/][editorconfig website]].

You will need to put an (or more) /.editorconfig/ file in your dirs

#+BEGIN_EXAMPLE .editorconfig
# EditorConfig is awesome: http://EditorConfig.org

# top-most EditorConfig file
root = true

# Unix-style newlines with a newline ending every file
[*]
end_of_line = lf
insert_final_newline = true

# 4 space indentation
[*.py]
indent_style = space
indent_size = 4

# Tab indentation (no size specified)
[*.js]
indent_style = tab

# Indentation override for all JS under lib directory
[lib/**.js]
indent_style = space
indent_size = 2

# Matches the exact files either package.json or .travis.yml
[{package.json,.travis.yml}]
indent_style = space
indent_size = 2
#+END_EXAMPLE 

#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package editorconfig)
#+END_SRC

** Workspaces

*** Projectile                                                   :mode:minor:
#+BEGIN_SRC emacs-lisp :tangle yes
    (req-package projectile
                 :init
                 (projectile-global-mode))
#+END_SRC
**** Keybindings                                                :keybindings:
"C-c p" followed by a key 
*** spaces                                                       :mode:minor:
#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package spaces)
#+END_SRC
** Language specifics
*** Javascript
**** Tern                                                        :mode:minor:
#+BEGIN_SRC emacs-lisp :tangle yes
  ;; Set up the location of the tern .el files
  (if is-osx 
      (add-to-list 'load-path "~/.tern/emacs")
      (add-to-list 'load-path "/usr/local/lib/node_modules/tern/emacs"))

  (autoload 'tern-mode "tern.el" nil t)
  (eval-after-load 'tern
     '(progn
        (require 'tern-auto-complete)
        (tern-ac-setup)))

#+END_SRC

**** TODO gives error
eval-buffer: Cannot open load file: auto-complete




*** html & css

**** Emmet                                                       :mode:minor:
#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package emmet-mode)
#+END_SRC
** External services

*** Gist                                                         :mode:minor:
#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package gist)

#+END_SRC


* The end
#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package-finish)
#+END_SRC

* Not used
** From init.el
#+BEGIN_SRC emacs-lisp :tangle no
  ;; Set up load path
  (setq loadpath-mine (expand-file-name "conf" user-emacs-directory))
  (setq loadpath-vendor (expand-file-name "vendor" user-emacs-directory))

  (add-to-list 'load-path loadpath-mine)
  (add-to-list 'load-path loadpath-vendor)

  (require '_packages)
  (require '_global)
  (require '_appearance)
  (require '_key_bindings)

  (require 'theme-park-mode)

  ;; Functions (load all files in defuns-dir)
  (setq defuns-dir (expand-file-name "defuns" user-emacs-directory))
  (dolist (file (directory-files defuns-dir t "\\w+"))
    (when (file-regular-p file)
      (load file)))

  (when is-mac (require '_mac))
  

#+END_SRC

** Packages

** global

** appearance
   
** key bindings
   
** mac

